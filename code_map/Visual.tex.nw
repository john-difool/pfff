\documentclass{article}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\newif\iffacebook

\finaltrue\verbosefalse\facebooktrue
%\finalfalse\verbosetrue\facebooktrue

%cf also some \newif below

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------
%thx to LP, changed for the better a few things :)
% - factorized types
% - helped identify features
% - helped put together related stuff, for instance htop_entities
%   and the mixed/summary view
% - helped split in macrolevel and microlevel code
% - helped the split of view2.ml in view_mainmap, minimap, ui_search, etc.
% - easier to do search and replace on all files, just do it here :)

%thx to pfff_visual:
% - splitted big files like draw.ml and view.ml because saw they were too
%   big

%history LP-ization:
% - skeleton; a not too bad TOC
% - put all content of files in the Extra section
% - split the files in chunks (for type, helpers, ...), using
%   my emacs macro
% - distribute parts of the file before
% - TODO add figures (hand made)
% - TODO add biblio

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{noweb}
\noweboptions{}
%note: allow chunk to be on different pages, so less white space at
%  bottom of pages
\def\nwendcode{\endtrivlist \endgroup}
\let\nwdocspar=\par

\usepackage{xspace}

\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}

\usepackage{url}
\iffinal
\usepackage{hyperref}
\hypersetup{colorlinks=true}
\fi

\usepackage[pageref]{backref}
\def\backref{{\footnotesize cited page(s)}~}%en: \def\backref{{\footnotesize cited page(s)}~}


\usepackage{multirow}

\usepackage{booktabs} 
\newcommand{\otoprule}{\midrule[\heavyrulewidth]}

\usepackage{graphicx}

%\usepackage{fullpage}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\implemtrue
\implemoverviewtrue
\wantrepetitivecodefalse
\allcodefalse

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
CodeMap
}\\
Google Maps for Source Code\\
{version 0.3}
}

\author{
Yoann Padioleau\\
\texttt{pad@fb.com}
}
%dup: authors.txt

\maketitle 

%dup: with section Copyright
%\pagebreak
\hrule
\begin{quote}
    Copyright \copyright{}  2010-2012 Facebook \\
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3.
\end{quote}
\hrule
%\pagebreak
% if implem is included, then the doc contains the full source code
% so the copyright should be LGPL ?

\iffinal
\begingroup
\hypersetup{colorlinks=true, linkcolor=blue}
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\section{Introduction}

\subsection{Motivations}
\begin{verbatim}
(*
 * This file is the basis for a new kind of code visualizer, 
 * with real time zoom on a treemap and partial thumbnails with anamorphic
 * code; A google maps but on code :)
 * 
 * 
 * By playing with colors, size, fonts, and transparency, can show lots
 * of stuff.
 * 
 * There is not a single view that can accomodate all 
 * navigation/code-understanding programmer needs. So we provide multiple
 * features that can display things at different levels:
 *  - minimap, for context and quick navigation
 *  - zoomable/draggable map
 *  - content thumbnails, with anamorphic text for more important entities
 *  - magnifying glass on the zoomable map (=> have then 3 layers of zoom
 *    where can each time see the context)
 *  - clickable map so redraw treemap on focused dir (focus, but no more
 *    context, except in the minimap maybe one day)
 *  - speedbar for view histories
 *    (could also provide thumbnails on view histories :) )
 *  - zoom and mouse-follow
 * 
 * That's lots of features. In a way tools like Powerpoint also provide
 * multiple displays on the same data and with zoomable slides, global
 * view on the set of slides, slides thumnails, etc.
 *
 * maxim of information visualization:
 *  - show the data
 *  - show comparisons
 *)

\end{verbatim}

\begin{verbatim}
can copy also what is inside Treemap.tex.nw
\end{verbatim}

\begin{verbatim}
%integrate visualizer and source code ! separate skill for now
%later: integrate more artifacts. See vision.txt

whole program visualization. To actually see the architecture.
\end{verbatim}

\begin{verbatim}
%It also abstract away like PofFS how you organize your information.
If have one big test file or many small test files for instance,
then it does not matter, you can see all of the information at once
as it was a giant tiling plane.
So poffs is a kind of a precursor to codemap :)
\end{verbatim}

Note that this is not a replacement for Emacs or Vi, but more a
companion that works with Emacs or Vi, a little bit
like the Speedbar Emacs project, except it is using a treemap
instead of a classic hiearchy browser.

%vs emacs ?
%vs eclipse ? 

% follow movment towards tiling, ex: xmonad haskell window manager

\subsection{Getting started}

\begin{verbatim}
 * ./configure -visual
 * 
 * port install gtk2
 * port install cairo
 * port install freetype
 * port install mysql5-devel
 * 
\end{verbatim}

\subsection{Copyright}

The source code of \pfff is governed by the following copyright:
<<Facebook copyright>>=
(* Yoann Padioleau
 * 
 * Copyright (C) 2010-2012 Facebook
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 * 
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)
@ 
%alt: (* Copyright 2009, 2010 Facebook. All Rights Reserved. *)

\subsection{About this document}
#include "About.tex.nw"

\section{Examples of Use}

\begin{verbatim}
put cool scenario of use. cool question and how can get visual answer to
those questions!
\end{verbatim}

\subsection{Viewing the Linux kernel}

Here are the basics:
As you move the mouse, the blue highlighted areas are the next
level of directories.
Double-clicking zooms in on the blue-highlighted area.
Right-clicking zoom directly to the file under the cursor.
Middle-clicking open the file under the cursor in your
emacs provided you have M-x server-start and have emacsclient 
in your path.


<<interface_doc>>=
let interface_doc = "
This tool displays a \"code map\" of a software project using
Treemaps. \"Treemaps display hierarchical (tree-structured) data as a
set of nested rectangles. Each branch of the tree is given a 
rectangle, which is then tiled with smaller rectangles representing
sub-branches. A leaf node's rectangle has an area proportional 
to a specified dimension on the data.
\" - http://en.wikipedia.org/wiki/Treemapping:

In our case the dimension is the size of the file.
Moreover each file is colored according to its
\"category\": display code, third party code, etc.
See the legend. We use basic heuristcs based on the
name of the files and directory.

Files and directories are also sorted alphabetically
and partially ordered from top to bottom and left to right. 
So a toplevel 'zzz' subdirectory should be located at the bottom 
right of the screen.

As you move the mouse, the blue highlighted areas are the next
level of directories.

Double-clicking zooms in on the blue-highlighted area.
Right-clicking zoom directly to the file under the cursor.
Middle-clicking open the file under the cursor in your
favourite editor (provided you have M-x server-start
and have emacsclient in your path).

"
@ 


\subsection{Viewing Pfff itself}

\subsection{Generic semantic visual feedback}

\begin{verbatim}
% big = use
% green = tested
% purple = bad code

%todo: more scenario/workflow showing cool use of codemaps

%sgrep connection ?

% see semantic info like  takeArgByRef or use of globals or ContainDynCall
%  or TODO dead func, 
\end{verbatim}


\section{Implementation Overview}

\begin{verbatim}
% say that model/view/controller
\end{verbatim}

\begin{verbatim}
 * Archi: There are different kinds of "drawings":
 *  - 'paint', which does the heavy and expensive rendering
 *  - 'expose', which assemble the already painted pixmaps/layers and allow
 *    moving parts such as overlay rectangles

 * There are also 'draw' which is called by the 'paint'. 'Paint' creates
 * the cairo context and adjust the scaling if needed and then call
 * 'draw'
 
 * then there are cairo layers.

 * 
 * Assumes the treemap contains the absolute paths to existing files/dirs.

\end{verbatim}

\begin{verbatim}
concepts: 
user vs device
see Cairo/Gtk appendix

macro vs micro level
\end{verbatim}

\begin{verbatim}
Plan for following sections.
Dependencies diagram and Tabular.
 - main
 - treemap
 - semantic info and parser
 - assembling layers
 - gtk/cairo
\end{verbatim}

\section{Main}

<<main flags>>=
(* on Macos lion, X11 resizes the window to a smaller size so
 * no point in starting with a big screen_size :(
 *)
let screen_size = ref 1
let legend = ref true

(* if not specified, codemap will try to use files in the current directory *)
let db_file    = ref (None: Common.filename option)
let graph_file = ref (None: Common.filename option)
let layer_file = ref (None: Common.filename option)
let layer_dir  = ref (None: Common.dirname option)

(* See also Gui.synchronous_actions *)
let test_mode = ref (None: string option)
@

<<main_action()>>=
let main_action xs = 
  set_gc ();
  Logger.log Config_pfff.logger "codemap" None;

  let _locale = GtkMain.Main.init () in
  pr2 (spf "Using Cairo version: %s" Cairo.compile_time_version_string);

  let root = Common2.common_prefix_of_files_or_dirs xs in
  pr2 (spf "Using root = %s" root);

  let model = Async.async_make () in

  let layers = 
    match !layer_file, !layer_dir, xs with
    | Some file, _, _ -> 
        [Layer_code.load_layer file]
    | None, Some dir, _ 
    | None, None, [dir] -> 
        layers_in_dir dir +> List.map Layer_code.load_layer
    | _ -> []
  in
  let layers_with_index = 
    Layer_code.build_index_of_layers ~root 
      (match layers with 
      (* not active by default ? it causes some problems  *)
      | [layer] -> [layer, false]
      | _ -> layers +> List.map (fun x -> x, false)
      )
  in

  let db_file = 
    match !db_file, xs with
    | Some file, _ -> Some file
    | None, [dir] ->
      let candidates = [
          Filename.concat dir Database_code.default_db_name;
          Filename.concat dir Database_code.default_db_name ^ ".json";
      ] in
      (try 
        Some (candidates +> List.find (fun file -> Sys.file_exists file))
      with Not_found -> None
      )
      | _ -> None
  in
  db_file +> Common.do_option (fun db -> 
    pr2 (spf "Using pfff light db: %s" db)
  );
  let graph_file = 
    match !graph_file, xs with
    | Some file, _ -> Some file
    | None, [dir] ->
      let candidates = [
          Filename.concat dir Graph_code.default_graphcode_filename;
      ] in
      (try 
        Some (candidates +> List.find (fun file -> Sys.file_exists file))
      with Not_found -> None
      )
    | _ -> None
  in
  graph_file +> Common.do_option (fun db -> 
    pr2 (spf "Using graphcode: %s" db)
  );

  let dw = 
    Model.init_drawing treemap_generator model layers_with_index xs root in

  (* This can require lots of stack. Make sure to have ulimit -s 40000.
   * This thread also cause some Bus error on MacOS :(
   * so have to use Timeout instead when on the Mac
   *)
  (if Cairo_helpers.is_old_cairo() 
  then
    Thread.create (fun () ->
      Async.async_set (build_model root db_file graph_file) model;
    ) ()
    +> ignore
   else 
    Async.async_set (build_model root db_file graph_file) model;
   (*
    GMain.Timeout.add ~ms:2000 ~callback:(fun () ->
      Model.async_set (build_model root dbfile_opt) model;
      false
    ) +> ignore
   *)
  );

  (* the GMain.Main.init () is done by linking with gtkInit.cmo *)
  View2.mk_gui 
    ~screen_size:!screen_size
    ~legend:!legend
    !test_mode
    (root, model, dw, db_file)
@

\section{The Model}

\subsection{The code database}

<<type model>>=
type model = {
  root: Common.dirname;

  db: Database_code.database option;
  <<model fields hook>>

  (* for microlevel use/def information *)
  g: Graph_code.graph option;
  (* fast accessors, for macrolevel use/def information  *)
  huses_of_file: (Common.filename, Common.filename list) Hashtbl.t;
  husers_of_file: (Common.filename, Common.filename list) Hashtbl.t;
  (* the lists are sorted by line number *)
  hentities_of_file: 
    (Common.filename, (int (* line *) * Graph_code.node) list)  Hashtbl.t;
 }
@

<<build_model>>=
let build_model2 root dbfile_opt graphfile_opt =   

  let db_opt = 
    match dbfile_opt with
    | None -> None
    | Some file -> Some (Database_code.load_database file)
  in
  (* todo: do like for graph_code below, let hentities, hfiles_entities = ...*)
  let hentities = 
    Model_database_code.hentities root db_opt in
  let hfiles_entities = 
    Model_database_code.hfiles_and_top_entities root db_opt in
  let all_entities = 
    Model_database_code.all_entities db_opt root in

  let big_grep_idx = Completion2.build_completion_defs_index all_entities in

  let g_opt =
    match graphfile_opt with
    | None -> None
    | Some file -> Some (Graph_code.load file)
  in
  let huses_of_file, husers_of_file, hentities_of_file =
    match g_opt with
    | None -> Hashtbl.create 0, Hashtbl.create 0, Hashtbl.create 0
    | Some g ->
      let a, b = Model_graph_code.build_uses_and_users_of_file g in
      let c = Model_graph_code.build_entities_of_file g in
      Common.hash_of_list a, Common.hash_of_list b, Common.hash_of_list c
  in
  
  let model = { Model.
        root = root;
        db = db_opt;
        hentities; hfiles_entities; big_grep_idx;
        g =  g_opt;
        huses_of_file; husers_of_file;
        hentities_of_file;
  }
  in
  (*
    let model = Ancient2.mark model in
    Gc.compact ();
  *)
(*
  (* sanity check *)
  let hentities = (Ancient2.follow model).Model.hentities in
  let n = Hashtbl.length hentities in
  pr2 (spf "before = %d" n);
  let cnt = ref 0 in
  Hashtbl.iter (fun k v -> pr2 k; incr cnt) hentities;
  pr2 (spf "after = %d" !cnt);
  (* let _x = Hashtbl.find hentities "kill" in *)
*)
  model

let build_model a b = 
  Common.profile_code "View.build_model" (fun () ->
    build_model2 a b)
@ 


\subsection{The treemap generator}

<<treemap_generator>>=
let treemap_generator paths = 
  let treemap = Treemap_pl.code_treemap ~filter_file:!filter paths in
  let algo = Treemap.Ordered Treemap.PivotByMiddle in
  let rects = Treemap.render_treemap ~algo ~big_borders:!Flag.boost_label_size
    treemap in
  Common.pr2 (spf "%d rectangles to draw" (List.length rects));
  rects
@ 

\subsection{The final model}

<<type drawing>>=
(* All the 'float' below are to be intepreted as user coordinates except when
 * explicitely mentioned. All the 'int' are usually device coordinates.
 *)
type drawing = {

  (* computed lazily, semantic information about the code *)
  dw_model: model Async.t;
  (* to compute a new treemap based on user's action *)
  treemap_func: Common.path list -> Treemap.treemap_rendering;

  (* Macrolevel. In user coordinates from 0 to T.xy_ratio for 'x' and 0 to 1
   * for 'y'. Assumes the treemap contains absolute paths (tr.tr_label).
   *)
  treemap: Treemap.treemap_rendering;
  (* Microlevel. When we render content at the microlevel, we then need to
   * know to which line corresponds a position and vice versa.
   *)
  microlevel: (Treemap.treemap_rectangle, microlevel) Hashtbl.t;

  (* generated from dw.treemap, contains readable path relative to model.root *)
  readable_file_to_rect: 
    (Common.filename, Treemap.treemap_rectangle) Hashtbl.t;
  (* coupling: = List.length treemap *)
  nb_rects: int; 
  (* This is to display readable paths. When fully zoomed it's a filename *)
  current_root: Common.path;

  mutable layers: Layer_code.layers_with_index;

  <<fields drawing query stuff>>

  dw_settings: settings;

  <<fields drawing main view>>

  <<fields drawing viewport>>

  <<fields drawing minimap>>
}
  <<type settings>>
@

\subsection{The microlevel specific model}

<<type context>>=
(* a slice of drawing used in the drawing functions *)
type context = {
  model: model Async.t;
  settings:settings;
  nb_rects_on_screen: int;
  grep_query: (Common.filename, int) Hashtbl.t;
  layers_microlevel: 
   (Common.filename, (int, Simple_color.emacs_color) Hashtbl.t) Hashtbl.t;
}
@ 

\subsection{On filenames}

\begin{verbatim}
quite tricky. Also had pbs with our testing code. Relative path
are convenient but bad in code. 

- relative
- absolute
- readable

need readable in files so can reuse (for code light database and layers,
see section X and Y later)
\end{verbatim}

<<readable_to_absolute_filename_under_root sig>>=
val readable_to_absolute_filename_under_root :
  root:Common.path -> string -> string
@

<<actual_root_of_db sig>>=
val actual_root_of_db : 
  root:Common.path -> Database_code.database -> string
@


<<readable_to_absolute_filename_under_root>>=
(* People may run the visualizer on a subdir of what is mentionned in the
 * database code (e.g. subdir ~/www/flib of ~/www). The light_db
 * contains only readable paths (e.g. flib/foo.php); the reason for
 * those readable paths is that we want to reuse the light_db
 * and share it among multiple users which may have
 * different paths for their own software repo (e.g. ~/www4/).
 * 
 * When the user select an entity through the search box,
 * we will know the readable paths of the entity he is looking for
 * but we need a full path for refreshing the treemap.
 * We can not just concatenate the root with the readable paths which
 * in the example would lead to the path  ~/www/flib/flib/foo.php.
 * 
 * The goal of the function below is given a readable path like
 * flib/foo.php and a root like ~/www/flib  to recognize the common part
 * and return a valid fullpath like ~/www/flib/foo.php
 * 
 *)
let rec readable_to_absolute_filename_under_root ~root filename =

  (* the root may be a filename *)
  let root_dir = 
    if Common2.is_directory root then root
    else Filename.dirname root
  in

  let root_and_parents =
    Common2.inits_of_absolute_dir root_dir +> List.rev
  in
  try 
    root_and_parents +> Common2.return_when (fun dir ->
      let path = Filename.concat dir filename in
      if Sys.file_exists path
      then Some path
      else None
    )
  with Not_found ->
    failwith 
      (spf "can't find file %s with root = %s" filename root)
@


<<actual_root_of_db>>=
let actual_root_of_db ~root db =
  let a_file = (db.Db.entities.(0)).Db.e_file in
  let absolute_file = 
    readable_to_absolute_filename_under_root root a_file in
  
  if absolute_file =~ ("\\(.*\\)/" ^ a_file)
  then Common.matched1 absolute_file
  else failwith (spf "Could not find actual_root of %s under %s: "
                    absolute_file root)
@


\subsection{Misc}

<<hentities sig>>=
val hentities :
  Common.path -> Database_code.database option -> 
  (string, Database_code.entity) Hashtbl.t
@
<<model fields hook>>=
(* fast accessors *)
hentities : (string, Database_code.entity) Hashtbl.t;
@ 



<<hentities()>>=
(* We want to display very often used functions in bigger size font.
 * Enter database_code.ml which provides a language-independent database of
 * information on source code.
 * 
 * We compute the entities outside init_drawing because
 * init_drawing can be called multiple times (when we zoom in)
 * and we dont want the heavy entities computation to be 
 * repeated.
 *)
let hentities root db_opt = 
  let hentities = Hashtbl.create 1001 in

  db_opt +> Common.do_option (fun db ->

    let actual_root = actual_root_of_db ~root db in

      (* todo sanity check that db talks about files
       * in dirs_or_files ? Ensure same readable path.
       *)
      db.Db.entities +> Array.iter (fun e ->
        Hashtbl.add hentities
          e.Db.e_name
          {e with Db.e_file = 
              Filename.concat actual_root e.Db.e_file
          }
      );
  );
  hentities
@



<<init_drawing sig>>=
val init_drawing :
  ?width:int ->
  ?height:int ->
  ?width_minimap:int ->
  ?height_minimap:int ->
  (Common.path list -> Treemap.treemap_rendering) ->
  model Async.t ->
  Layer_code.layers_with_index ->
  Common.filename list -> 
  Common.dirname ->
  drawing
@

<<init_drawing()>>=
let init_drawing 
  (* This is a first guess. The first configure ev will force a resize. *)
  ?(width = 600)
  ?(height = 600)
  ?(width_minimap = 60)
  ?(height_minimap = 60)
  func 
  model
  layers
  paths
  root
 =

  let paths = List.map Common2.relative_to_absolute paths in
  let current_root = Common2.common_prefix_of_files_or_dirs paths in
  let treemap = 
    Common.profile_code "Visual.building the treemap" (fun () -> func paths) in
  let readable_file_to_rect =
    treemap +> Common.map_filter (fun rect ->
      if not rect.T.tr_is_node
      then 
        let file  = rect.T.tr_label in
        let readable = Common.filename_without_leading_path root file in
        Some (readable, rect)
      else None
    ) +> Common.hash_of_list
  in
  let pm = new_pixmap ~width ~height in

  {
    treemap;
    nb_rects = List.length treemap;
    current_root;
    treemap_func = func;

    dw_model = model;
    layers = layers;

    readable_file_to_rect;
    microlevel = Hashtbl.create 0;

    current_query = "";
    current_searched_rectangles = [];
    current_entity = None;
    current_grep_query = Hashtbl.create 0;

    pm;
    overlay = Cairo.surface_create_similar (CairoH.surface_of_pixmap pm) 
      Cairo.CONTENT_COLOR_ALPHA width height;
    width;
    height;

    dw_settings = {
      (* todo: too fuzzy for now *)
      draw_summary = false;

      draw_searched_rectangles = true;
    };


    zoom = 1.;
    xtrans = 0.;
    ytrans = 0.;

    drag_pt = { Cairo.x = 0.0; Cairo.y = 0.0 };
    in_dragging = false;
    in_zoom_incruste = false;

    width_minimap = width_minimap;
    height_minimap = height_minimap;
    pm_minimap = new_pixmap ~width:width_minimap ~height:width_minimap;
    drag_pt_minimap = { Cairo.x = 0.0; Cairo.y = 0.0 };

  }
@

\section{The UI}

\subsection{Overall organisation}

\begin{verbatim}
 * Overall UI organisation:
 *  - menu
 *  - toolbar
 *  - mainview (treemap | minimap/legend)
 *  - statusbar 
 * 
 * Conventions and info: see commons/gui.ml
\end{verbatim}

<<mk_gui sig>>=
val mk_gui :
  screen_size:int ->
  legend:bool ->
  'b option -> 
  (string (* root *) * 
   Model2.model Async.t * 
   Model2.drawing * 
   Common.filename option) -> 
  unit
@ 


<<view globals>>=
(* when some widgets need to access other widgets *)

(* Note that because we use toplevels 'let' for the GUI elements below,
 * Gtk must have also been initialized via a toplevel element, or
 * initialized by including gtkInit.cmo earlier in the linking command.
 *)

(* ugly, todo use model.root instead? *)
let root_orig () = 
  (Common2.list_last !Controller.dw_stack).M.current_root

@ 

\subsection{Menu}

\subsection{Toolbar}

\subsection{Main view}

\subsection{Status bar}

\subsection{Misc}

<<mk_gui()>>=
let mk_gui ~screen_size ~legend test_mode (root, model, dw, dbfile_opt) =

  let dw = ref dw in
  Common.push2 !dw Controller.dw_stack;

  let width, height, minimap_hpos, minimap_vpos = 
    Style.windows_params screen_size in

  let w = GWindow.window 
    ~title:(Controller.title_of_path root)
    ~width
    ~height
    ~allow_shrink: true
    ~allow_grow:true
    () 
  in
  let statusbar = GMisc.statusbar () in
  let ctx = statusbar#new_context "main" in

  Controller._set_title := (fun s -> w#set_title s);
  Controller._statusbar_addtext := (fun s -> ctx#push s +> ignore);

  let accel_group = GtkData.AccelGroup.create () in
  w#misc#set_name "main window";

  let quit () = 
    (*Controller.before_quit_all model;*)
    GMain.Main.quit ();
  in

  w#add_accel_group accel_group;

  (*-------------------------------------------------------------------*)
  (* Layout *)
  (*-------------------------------------------------------------------*)

  (* if use my G.mk style for that, then get some pbs when trying
   * to draw stuff :(
   *)
  let vbox = GPack.vbox ~packing:w#add () in

    (*-------------------------------------------------------------------*)
    (* Menu *)
    (*-------------------------------------------------------------------*)
    vbox#pack (G.mk (GMenu.menu_bar) (fun m -> 
      
      let factory = new GMenu.factory m in

      factory#add_submenu "_File" +> (fun menu -> 
        let fc = new GMenu.factory menu ~accel_group in

        (* todo? open Db ? *)

        fc#add_item "_Open stuff from db" ~key:K._O ~callback:(fun () -> 
          ();
        ) +> ignore;
        fc#add_separator () +> ignore;

        fc#add_item "_Quit" ~key:K._Q ~callback:quit;
      ) +> ignore;

      factory#add_submenu "_Edit" +> (fun menu -> 
        GToolbox.build_menu menu ~entries:[
          `S;
        ];
      ) +> ignore;

      factory#add_submenu "_Move" +> (fun menu -> 
        let fc = new GMenu.factory menu ~accel_group in

        (* todo? open Db ? *)
        fc#add_item "_Go back" ~key:K._B ~callback:(fun () -> 
          !Controller._go_back dw;
        ) +> ignore;

        fc#add_item "_Go to example" ~key:K._E ~callback:(fun () -> 
          let model = !dw.dw_model in
          let model = Async.async_get model in
          match !dw.current_entity, model.db with
          | Some e, Some db ->
              (match e.Db.e_good_examples_of_use with
              | [] -> failwith "no good examples of use for this entity"
              | x::xs ->
                  let e = db.Db.entities.(x) in
                  let file = e.Db.e_file in

                  let final_file = 
                    Model_database_code.readable_to_absolute_filename_under_root
                      file ~root:!dw.current_root in

                  !Controller._go_dirs_or_file 
                    ~current_entity:(Some e) dw [final_file];
              )
          | _ -> failwith "no entity currently selected or no db"
        ) +> ignore ;
      );

      factory#add_submenu "_Search" +> (fun menu -> 
        let fc = new GMenu.factory menu ~accel_group in

        (* todo? open Db ? *)
        fc#add_item "_Git grep" ~key:K._G ~callback:(fun () -> 

          let res = Ui_search.dialog_search_def !dw.dw_model in
          res +> Common.do_option (fun s ->
            let root = 
              (* could also support local grep? and use !dw.root instead ?  *)
              root_orig ()
            in
            let matching_files = Ui_search.run_grep_query ~root s in
            let files = matching_files +> List.map fst +> Common2.uniq in
            let current_grep_query = 
              Some (Common.hash_of_list matching_files)
            in
            !Controller._go_dirs_or_file ~current_grep_query dw files
          );
        ) +> ignore;

        fc#add_item "_Tbgs query" ~key:K._T ~callback:(fun () -> 

          let res = Ui_search.dialog_search_def !dw.dw_model in
          res +> Common.do_option (fun s ->
            let root = !dw.current_root in
            let matching_files = Ui_search.run_tbgs_query ~root s in
            let files = matching_files +> List.map fst +> Common2.uniq in
            let current_grep_query = 
              Some (Common.hash_of_list matching_files)
            in
            !Controller._go_dirs_or_file ~current_grep_query dw files
          );
        ) +> ignore;

      );
      factory#add_submenu "_Layers" +> (fun menu -> 
        let layers = 
          !dw.layers.Layer_code.layers +> List.map (fun (layer, active) ->
            (layer.Layer_code.title, active, (fun b -> 
              if b then
                Ui_layers.choose_layer ~root:(root_orig())
                  (Some layer.Layer_code.title) dw;
            ))
          )
        in
        (* todo: again, make the architecture a layer so less special cases *)
        let entries = [`R (
             ("Architecture", true, (fun b ->
               Ui_layers.choose_layer ~root:(root_orig()) None dw;
             ))::
             layers)
        ]
        in
        GToolbox.build_menu menu ~entries
      );

      factory#add_submenu "_Misc" +> (fun menu -> 
        let fc = new GMenu.factory menu ~accel_group in

        (* todo? open Db ? *)

        fc#add_item "_Refresh" ~key:K._R ~callback:(fun () -> 
          let current_root = !dw.current_root in
          let _old_dw = Common2.pop2 Controller.dw_stack in
          (* have to disable the AST caching.
           * todo? disable all entries in the cache ?
           *)
          if Common2.is_file current_root
          then Parsing2.disable_file_in_cache current_root;

          !Controller._go_dirs_or_file dw [current_root];

        ) +> ignore;

        fc#add_item "_Zoom" ~key:K._Z ~callback:(fun () -> 
          !dw.in_zoom_incruste <- not (!dw.in_zoom_incruste);
          !Controller._refresh_da();
        ) +> ignore;

      );

      factory#add_submenu "_Help" +> (fun menu -> 
        let fc = new GMenu.factory menu ~accel_group in

        fc#add_item "_Interface" ~key:K._H ~callback:(fun () -> 
            G.dialog_text Help.interface_doc "Help"
        ) +> ignore;

        fc#add_item "_Legend" ~key:K._L ~callback:(fun () -> 
          raise Todo
        ) +> ignore;

        fc#add_item "_Help on Pfff" ~callback:(fun () -> 
            G.dialog_text "Read\nthe\nsource\n\ndude" "Help"
        ) +> ignore;
        fc#add_separator () +> ignore;
        fc#add_item "About" ~callback:(fun () -> 
            G.dialog_text "Brought to you by pad\nwith love" "About"
        ) +> ignore;
      );


    ));

    (*-------------------------------------------------------------------*)
    (* toolbar *)
    (*-------------------------------------------------------------------*)

    vbox#pack (G.mk (GButton.toolbar) (fun tb ->

(*
      tb#insert_widget (G.mk (GButton.button ~stock:`OPEN) (fun b -> 
        b#connect#clicked ~callback:(fun () -> 
          pr2 "OPEN";
        );
      ));
      tb#insert_widget (G.mk (GButton.button ~stock:`SAVE) (fun b -> 
        b#connect#clicked ~callback:(fun () -> 
          pr2 "SAVE";
        );
      ));
      tb#insert_space ();
      tb#insert_button ~text:"SAVE THIS" ~callback:(fun () -> 
        pr2 "SAVE THIS";
      ) () +> ignore;
      tb#insert_space ();

*)
      let idx = (fun () -> 
        let model = Async.async_get model in
        model.Model2.big_grep_idx 
      )
      in

      let entry = 
        Completion2.my_entry_completion_eff 
         ~callback_selected:(fun entry str file e ->
          (* pb is that we may have run the visualizer on a subdir
           * of what is mentionned in the database code. We have
           * then to find the real root.
           *)
          entry#set_text "";

          let readable_paths = 
            (* hack to handle multidirs *)
            match e.Db.e_kind with
            | Database_code.MultiDirs ->
                (* hack: coupling: with mk_multi_dirs_entity *)
                Common.split "|" e.Db.e_file
            | _ ->
                [e.Db.e_file]
          in

          let final_paths = 
            readable_paths +> List.map 
              (Model_database_code.readable_to_absolute_filename_under_root 
                 ~root:!dw.current_root)
          in

          pr2 (spf "e= %s, final_paths= %s" str(Common.join "|" final_paths));
          !Controller._go_dirs_or_file ~current_entity:(Some e) dw final_paths;
          true
        )
        ~callback_changed:(fun str ->
          !dw.current_query <- str;
          !dw.current_searched_rectangles <- [];

          if !dw.dw_settings.draw_searched_rectangles
          then begin
            (* better to compute once the set of matching rectangles
             * cos doing it each time in motify would incur too much
             * calls to ==~
             *)
            let minimum_length = 3 in

            if String.length str > minimum_length then begin

              let rects = !dw.treemap in
              let re_opt = 
                try Some (Str.regexp (".*" ^ str))
               (* can raise exn when have bad or not yet complete regexp *)
                with _ -> None
              in
              let res = 
                match re_opt with
                | None -> []
                | Some re ->
                    rects +> List.filter (fun r -> 
                      let label = r.T.tr_label +> String.lowercase in
                      label ==~ re
                    )
              in
              !dw.current_searched_rectangles <- res;
              
            end;
            let cr_overlay = Cairo.create !dw.overlay in
            CairoH.clear cr_overlay;
            View_overlays.draw_searched_rectangles ~dw:!dw;
            !Controller._refresh_da();
          end
        )
        idx
      in

      tb#insert_widget (G.with_label "Search:" entry#coerce);

      tb#insert_widget (G.mk (GButton.button ~stock:`GO_BACK) (fun b -> 
        b#connect#clicked ~callback:(fun () -> 
          !Controller._go_back dw;
        )
      ));

      tb#insert_widget (G.mk (GButton.button ~stock:`GO_UP) (fun b -> 
        b#connect#clicked ~callback:(fun () -> 
          let current_root = !dw.current_root in
          !Controller._go_dirs_or_file dw [Common2.dirname current_root];
        )
      ));

      tb#insert_widget (G.mk (GButton.button ~stock:`GOTO_TOP) (fun b -> 
        b#connect#clicked ~callback:(fun () -> 
          let top = Common2.list_last !Controller.dw_stack in
          (* put 2 in the stack because _go_back will popup one *)
          Controller.dw_stack := [top; top];
          !Controller._go_back dw;

        )
      ));

    ));

    (*-------------------------------------------------------------------*)
    (* main view *)
    (*-------------------------------------------------------------------*)

    let hpane = GPack.paned `HORIZONTAL
      ~packing:(vbox#pack ~expand:true ~fill:true) () in

    let da = GMisc.drawing_area () in
    da#misc#set_double_buffered false;

    hpane#add1 da#coerce;

    let vpane = GPack.paned `VERTICAL () in
    hpane#set_position minimap_hpos;

    if legend then hpane#add2 vpane#coerce;

    let da2 = GMisc.drawing_area () in
    da2#misc#set_double_buffered false;
    vpane#add1 da2#coerce;

    
    let da3 = GMisc.drawing_area () in
    vpane#set_position minimap_vpos;
    vpane#add2 da3#coerce;

    da#misc#set_can_focus true ;
    da#event#add [ `KEY_PRESS;
                   `BUTTON_MOTION; `POINTER_MOTION;
                   `BUTTON_PRESS; `BUTTON_RELEASE ];

    da2#misc#set_can_focus true ;
    da2#event#add [ `KEY_PRESS;
                 (* weird, but because even if didn't say
                  * POINTER_MOTION here, the minimap still
                  * gets an event for mouse over :(
                  *)
                    `BUTTON_MOTION; `POINTER_MOTION;
                    `BUTTON_PRESS; `BUTTON_RELEASE ];


    da#event#connect#expose ~callback:(expose da dw) +> ignore;
    da#event#connect#configure ~callback:(configure da dw) +> ignore;

    da3#event#connect#expose ~callback:(expose_legend da3 dw) +> ignore;

(*
    da2#event#connect#expose ~callback:(expose_minimap da2 dw) +> ignore;
    da2#event#connect#configure ~callback:(configure_minimap da2 dw) +> ignore;
*)

    da#event#connect#button_press   
      (View_mainmap.button_action da dw) +> ignore;
    da#event#connect#button_release 
      (View_mainmap.button_action da dw) +> ignore;

    da#event#connect#motion_notify  
      (View_overlays.motion_notify (da,da2) dw) +> ignore; 

(*
    da2#event#connect#button_press  
      (button_action_minimap (da,da2) dw) +> ignore;
    da2#event#connect#button_release 
      (button_action_minimap (da, da2) dw) +> ignore;
    da2#event#connect#motion_notify 
      (motion_notify_minimap (da,da2) dw) +> ignore; 
*)

    Controller._refresh_da := (fun () ->
      GtkBase.Widget.queue_draw da#as_widget;
    );
    Controller._refresh_legend := (fun () ->
      GtkBase.Widget.queue_draw da3#as_widget;
    );

    Controller._go_back := Ui_navigation.go_back;
    Controller._go_dirs_or_file := Ui_navigation.go_dirs_or_file;
      
(*
    da#event#connect#key_press ~callback:(key_pressed da dw);
*)

    (*-------------------------------------------------------------------*)
    (* status bar *)
    (*-------------------------------------------------------------------*)
    (* the statusbar widget is defined in beginning of this file because *)
    vbox#pack (*~from: `END*) statusbar#coerce;

  (*  )); *)

  (*-------------------------------------------------------------------*)
  (* End *)
  (*-------------------------------------------------------------------*)

  (* Controller._before_quit_all_func +> Common.push2 Model.close_model; *)

  GtkSignal.user_handler := (fun exn -> 
    pr2 "fucking callback";
    (* old: before 3.11: Features.Backtrace.print(); *)
    let s = Printexc.get_backtrace () in
    pr2 s;
    let pb = "pb: " ^ string_of_exn exn ^ "\n" ^ s in
    G.dialog_text ~text:pb ~title:"pb";
    raise exn
  );

  (* TODO: should do that on 'da', not 'w' 
  w#event#connect#key_press ~callback:(key_pressed (da,da2) dw) +> ignore;
  *)

(*
  w#event#connect#key_press ~callback:(fun ev -> 
    let k = GdkEvent.Key.keyval ev in
    (match k with
    | _ when k = Char.code 'q' -> 
        quit();
        true   
    | _ -> false
    )
  );
*)

  w#event#connect#delete    ~callback:(fun _  -> quit(); true) +> ignore;
  w#connect#destroy         ~callback:(fun () -> quit(); ) +> ignore;
  w#show ();

  (* test *)
  test_mode +> Common.do_option (fun s -> 
    (* View_test.do_command s model *)
    ()
  );

  (* Gui.gmain_idle_add ~prio: 1000 (idle dw) +> ignore; *)

  GtkThread.main ();
  ()
@

\section{The Controller}

\section{Macrolevel View: The Treemap}

%macro-level visualization. See also archi_code.ml.

\subsection{Principles}

% xyratio

\subsection{Drawing}

% \label{user-vs-device}

<<device_to_user_area>>=
(* still needed ? reuse helper functions above ? *)
let device_to_user_area dw = 
  with_map dw (fun cr ->

    let device_point = { Cairo. x = 0.0; y = 0.0 } in
    let user_point1 = Cairo.device_to_user cr device_point in
    let device_point = { Cairo.x = float_of_int dw.width; 
                         Cairo.y = float_of_int dw.height; } in
    let user_point2 = Cairo.device_to_user cr device_point in
    
    { F.p = CairoH.cairo_point_to_point user_point1;
      F.q = CairoH.cairo_point_to_point user_point2;
    }
  )
@ 


<<draw_treemap_rectangle sig>>=
val draw_treemap_rectangle :
  cr:Cairo.t -> 
  ?color:Simple_color.emacs_color option -> 
  ?alpha:float -> 
  Treemap.treemap_rectangle -> 
  unit
@ 

<<draw_treemap_rectangle()>>=
let draw_treemap_rectangle2 ~cr ?(color=None) ?(alpha=1.) rect =
  let r = rect.T.tr_rect in

  (let (r,g,b) = 
    let (r,g,b) = rect.T.tr_color +> Color.rgb_of_color +> Color.rgbf_of_rgb in
    match color with
    | None -> (r,g,b)
    | Some c -> 
        let (r2,g2,b2) = c +> Color.rgbf_of_string in
        (r2 + r / 20., g2 + g / 20., b2 + b / 20.)
  in
  Cairo.set_source_rgba cr r g b (alpha);
  );

  Cairo.move_to cr r.p.x r.p.y;
  Cairo.line_to cr r.q.x r.p.y;
  Cairo.line_to cr r.q.x r.q.y;
  Cairo.line_to cr r.p.x r.q.y;

  Cairo.fill cr;
  ()

let draw_treemap_rectangle ~cr ?color ?alpha a =
  Common.profile_code "View.draw_treemap_rectangle" (fun () -> 
    draw_treemap_rectangle2 ~cr ?color ?alpha a)
@ 


\subsection{Labels}

<<draw_treemap_rectangle_label_maybe sig>>=
val draw_treemap_rectangle_label_maybe :
  cr:Cairo.t -> 
  zoom:float -> 
  color:Simple_color.emacs_color option -> 
  Treemap.treemap_rectangle -> 
  unit
@ 


<<draw_treemap_rectangle_label_maybe>>=
let _hmemo_text_extent = Hashtbl.create 101

(* This can be quite cpu intensive. CairoH.text_extents is quite slow
 * so you must avoid calling it too much. A simple optimisation
 * when the treemap is big is to avoid trying to draw labels
 * that are too tiny already.
 * 
 * note that this function is also called when we mouse over a rectangle
 * in which case we redraw the label in a different color
 * 
 * design: good to have a color different for dir and files.
 * 
 * design: could decide to give different colors to dirs depending on its
 * depth, like red for toplevel dir, green, and so on, like I do for 
 * my code sections, but feel simpler to just have one.
 * The rectangles will already have different colors and in the end
 * the depth does not have that much meaning in projects. For instance
 * in java code there are lots of nested directories (org/apache/...),
 * in some projects there is always an intermediate src/ directory;
 * each software have different conventions.
 *)
let rec draw_treemap_rectangle_label_maybe2 ~cr ~zoom ?(color=None) rect =
  if !Flag.disable_fonts then ()
  else begin

  let lbl = rect.T.tr_label in
  let base = Filename.basename lbl in
  (* old: Common.is_directory_eff lbl *)
  let is_directory = rect.T.tr_is_node in

  let txt = 
    if is_directory
    then base ^ "/"
    else base
  in
  let color = 
    match color with
    | None -> 
        if is_directory 
        then "NavyBlue"
        else "black"
    | Some c -> c
  in

  Cairo.select_font_face cr "serif"
    Cairo.FONT_SLANT_NORMAL Cairo.FONT_WEIGHT_BOLD;

  let font_size, minus_alpha = 
    if not !Flag.boost_label_size
    then 
     (match rect.T.tr_depth with
    | 1 -> 0.1, 0.8
    | 2 -> 0.05, 0.2
    | 3 -> 0.03, 0.4
    | 4 -> 0.02, 0.5
    | 5 -> 0.02, 0.65
    | 6 -> 0.02, 0.7
    | _ -> 0.02, 0.8
     )
    else
    (match rect.T.tr_depth with
    | 1 -> 0.1, 0.8
    | 2 -> 0.06, 0.2
    | 3 -> 0.045, 0.3
    | 4 -> 0.041, 0.35
    | 5 -> 0.04, 0.4
    | 6 -> 0.03, 0.45
    | _ -> 0.02, 0.5
    )
  in
  let font_size = font_size / (zoom) (* use zoom factor inversely *) in
  let alpha = 1. - (minus_alpha / zoom) in

  try_draw_label 
    ~font_size_orig:font_size
    ~color ~alpha 
    ~cr ~rect txt
  end


and try_draw_label ~font_size_orig ~color ~alpha ~cr ~rect txt =

(* ugly: sometimes labels are too big. Should provide a way to
 * shorten them.
 * let txt = 
 * if true
 * then if txt =~ "org.eclipse.\\(.*\\)" then Common.matched1 txt else txt
 * else txt
 * in
 *)
(*
  let txt = 
  if true
  then if txt =~ "[^-]*-\\(.*\\)" then Common.matched1 txt else txt
  else txt
  in
*)
  let r = rect.T.tr_rect in
  
  let w = F.rect_width r in
  let h = F.rect_height r in

  let is_file = 
    (* old: try Common.is_file_eff rect.T.tr_label with _ -> false *)
    not rect.T.tr_is_node
  in

  (let (r,g,b) = color +> Color.rgbf_of_string in
   Cairo.set_source_rgba cr r g b alpha;
  );

  let rec aux ~font_size ~step =

    (* opti: this avoid lots of computation *)
    let font_size_real = CairoH.user_to_device_font_size cr font_size in

    if font_size_real < !Flag.threshold_draw_label_font_size_real
    then ()
    else begin

     CairoH.set_font_size cr font_size;

     (* opti:
      *  was let extent = CairoH.text_extents cr txt
      *)
     let th, base_tw = 
       Common.memoized _hmemo_text_extent (font_size, font_size_real) (fun ()->
         (* peh because it exercises the spectrum of high letters *)
         let extent = CairoH.text_extents cr "peh" in
         let tw = extent.Cairo.text_width in
         let th = extent.Cairo.text_height in
         th, tw
       )
     in
     let tw = float_of_int (String.length txt) * base_tw / 3. in
           
     
     (* will try first horizontally at a certain size, then
      * diagonally at a certain size, and if can't then reduce
      * the font_size (up to a certain limit) and try again
      * (first horizontally, then diagonally).
      *)
     match step with
     | 1 | 4 | 7 | 10 when tw < w && th < h && rect.T.tr_depth > 1 ->
           (* see http://cairographics.org/tutorial/#L3showtext 
            * for the logic behind the placement of the text
            *)
     
           let x = r.p.x + w / 2.0 - (tw / 2.0) in
           let y = r.p.y + h / 2.0 + (th / 2.0) in
       
           Cairo.move_to cr x y;
           CairoH.show_text cr txt;

           (* '<= 2' actually means "the toplevel entries" as 
            * the root is at depth=1
            *)
           if rect.T.tr_depth <= 2 then begin
             (let (r,g,b) = Color.rgbf_of_string "red" in
              Cairo.set_source_rgba cr r g b alpha;
             );
             Cairo.move_to cr x y;
             CairoH.show_text cr (String.sub txt 0 1);
           end
           
   
     | 2 | 5 | 8 | 11 when 
           tw < sqrt (w * w + h * h) && 
           th < min w h &&
             rect.T.tr_depth > 1 ->
           (* todo: try vertically ... *)
   
         (* you have to draw on a paper to understand this code below ... *)
   
         let tangent = h / w in
         let angle = atan tangent in
   
         (* right now we don't handle the fact that the text itself has
          * a height but below the x and y positions are just the
          * place of the very bottom of the first letter. In some way we trace a
          * line below the text in the diagonal of the rectangle. This means all
          * the text is on the top of the diagonal. It should be in the middle
          * of the diagonal. 
          * As a first fix we can artificially augment the angle ... ugly
          *)
         let angle = 
           min (angle + angle / 10.) (Math.pi / 2.) 
         in
   
         (* I love basic math *)
         let x = r.p.x + w / 2.0 - (cos angle * (tw / 2.0)) in
         let y = r.p.y + h / 2.0 - (sin angle * (tw / 2.0)) in
         Cairo.move_to cr x y;
   
           
         Cairo.rotate cr ~angle:angle;
         CairoH.show_text cr txt;
         Cairo.rotate cr ~angle:(-. angle);
         
         if rect.T.tr_depth <= 2 then begin
           (let (r,g,b) = Color.rgbf_of_string "red" in
            Cairo.set_source_rgba cr r g b alpha;
           );
           Cairo.move_to cr x y;
           Cairo.rotate cr ~angle:angle;
           CairoH.show_text cr (String.sub txt 0 1);
           Cairo.rotate cr ~angle:(-. angle);
         end;



   
     | 3 ->
         (* I am ok to go down to 70% *)
         let font_size = font_size_orig * 0.7 in
         aux ~step:4 ~font_size
     | 6 ->
         (* I am ok to go down to 50% of original *)
         let font_size = font_size_orig * 0.5 in
         aux ~step:7 ~font_size
   
     | 9 ->
         (* I am ok to go down to 30% of original for file only  *)
         if is_file
         then 
           let font_size = font_size_orig * 0.25 in
           aux ~step:10 ~font_size
         else ()
   
     (* this case is taken only for the first cases (1, 2, ..) when the
      * associated 'when' expression is false
      *)
     | n -> 
         if n >= 12
         then ()
         else aux ~step:(Pervasives.(+) n 1) ~font_size
    end
  in
  aux ~font_size:font_size_orig ~step:1 

let draw_treemap_rectangle_label_maybe ~cr ~zoom ~color rect =
  Common.profile_code "View.draw_label_maybe" (fun () ->
    draw_treemap_rectangle_label_maybe2 ~cr ~zoom ~color rect)
@ 


\subsection{Color code}

\begin{verbatim}
This is kind of interfile "aspect"
\end{verbatim}

<<paint_legend>>=
(* todo: make the architecture a layer so no need for special case *)
let draw_legend ~cr =

  let archis = Archi_code.source_archi_list in
  let grouped_archis = archis +> Common.group_by_mapped_key (fun archi ->
    let color = Treemap_pl.color_of_source_archi archi in
    (* I tend to favor the darker variant of the color in treemap_pl.ml hence
     * the 3 below
     *)
    let color = color ^ "3" in
    color
  )
  in
  let grouped_archis = grouped_archis +> List.map (fun (color, kinds) ->
    color, kinds +> List.map Archi_code.s_of_source_archi +> Common.join ", "
  ) in
  draw_legend_of_color_string_pairs ~cr grouped_archis

@ 

<<expose_legend>>=
let expose_legend da dw_ref ev = 
  let cr = Cairo_lablgtk.create da#misc#window in

  (* todo: make the architecture a layer so no need for special case *)
  let dw = !dw_ref in
  (if not (Layer_code.has_active_layers dw.layers)
  then Draw_legend.draw_legend ~cr
  else Draw_legend.draw_legend_layer ~cr dw.layers
  );
  true
@ 



\section{Microlevel View: Source Thumbnails}

% micro-level visualization. See also highlight_code.ml

\subsection{Principles}

\subsection{Drawing}

<<type draw_content_layout>>=
@ 


<<draw_treemap_rectangle_content_maybe sig>>=
(* will render (maybe) the file content of treemap_rectangle.tr_label *)
val draw_treemap_rectangle_content_maybe:
  cr:Cairo.t ->
  clipping:Figures.rectangle ->
  context:Model2.context ->
  Treemap.treemap_rectangle -> 
  Model2.microlevel option
@ 

\subsection{Entities size}

<<final_font_size_when_multiplier>>=
let final_font_size_when_multiplier 
    ~multiplier ~size_font_multiplier_multiplier 
    ~font_size ~font_size_real 
   = 
  let size_font_multiplier = multiplier in
  
  let font_size_adjusted = 
    if size_font_multiplier = 1.
    then font_size
    else 
      max 
       (font_size * size_font_multiplier * size_font_multiplier_multiplier)
       (font_size * 1.5)
  in
  
  let final_font_size = 
    Common2.borne ~min:font_size ~max:(font_size * 30.) font_size_adjusted
  in
  final_font_size
@ 


<<final_font_size_of_categ>>=
let final_font_size_of_categ ~font_size ~font_size_real categ = 

  let multiplier = Style.size_font_multiplier_of_categ ~font_size_real categ in
  (* as we zoom in, we don't want to be as big, and as
   * we zoom out we want to be bigger
   *)
  let size_font_multiplier_multiplier = 
     (*- 0.2 * font_size_real + 2. *)
    match font_size_real with
    | n when n < 3. -> 2.
    | n when n < 8. -> 1.5
    | n when n < 10. -> 1.
    | _ -> 0.5
  in
  Draw_common.final_font_size_when_multiplier 
    ~multiplier
    ~size_font_multiplier_multiplier
    ~font_size
    ~font_size_real
@ 


\subsection{Column layout}

<<font_size_when_have_x_columns>>=
let font_size_when_have_x_columns ~nblines ~chars_per_column ~w ~h ~with_n_columns = 
  let size_x = (w / with_n_columns) / chars_per_column in
  let size_y = (h / (nblines / with_n_columns)) in

  let min_font = min size_x size_y in
  min_font
@ 


<<optimal_nb_columns>>=
(* Given a file with nblines and nbcolumns (usually 80) and
 * a rectangle of w width and h height, what is the optimal
 * number of columns. The principle is to start at 1 column
 * and see if by adding columns we can have a bigger font.
 * We try to maximize the font_size.
 *)
let optimal_nb_columns ~nblines ~chars_per_column ~w ~h = 
  
  let rec aux current_font_size current_nb_columns = 
    let min_font = font_size_when_have_x_columns 
      ~nblines ~chars_per_column ~w ~h ~with_n_columns:current_nb_columns
    in
    if min_font > current_font_size
    then aux min_font (current_nb_columns + 1.)
    else 
      (* regression, then go back on step *)
      current_nb_columns - 1.
  in
  aux 0.0   1.
@


<<draw_column_bars>>=
let draw_column_bars2 ~cr layout r = 
  for i = 1 to int_of_float (layout.split_nb_columns - 1.) do
    let i = float_of_int i in
      
    Cairo.set_source_rgba cr 0.0 0.0 1. 0.2;

    let font_size_real = CairoH.user_to_device_font_size cr layout.lfont_size in
    let width = 
      if font_size_real > 5.
      then layout.lfont_size / 10.
      else layout.lfont_size
    in
    Cairo.set_line_width cr width;

    Cairo.move_to cr (r.p.x + layout.width_per_column * i) r.p.y;
    Cairo.line_to cr (r.p.x + layout.width_per_column * i) r.q.y;
    Cairo.stroke cr ;
  done
let draw_column_bars ~cr layout rect =
  Common.profile_code "View.draw_bars" (fun () ->
    draw_column_bars2 ~cr layout rect)
@ 


\subsection{Content rendering}

% thumbnails and actual source is same code! not like in visual studio

<<draw_content>>=
let draw_content2 ~cr ~layout ~context tr =

  let r = tr.T.tr_rect in
  let file = tr.T.tr_label in

  let font_size = layout.lfont_size in
  let font_size_real = CairoH.user_to_device_font_size cr font_size in

  if font_size_real > Style.threshold_draw_dark_background_font_size_real
  then begin

    (* erase what was done at the macrolevel *)
    if Hashtbl.length context.layers_microlevel > 0 then begin
      Draw_macrolevel.draw_treemap_rectangle ~cr ~color:(Some "white") 
        ~alpha:1.0 tr;
    end;

    let alpha = 
      match context.nb_rects_on_screen with
      | n when n <= 1 -> 0.95
      | n when n <= 2 -> 0.8
      | n when n <= 10 -> 0.6
      | _ -> 0.3
    in
    (* unset when used when debugging the layering display *)
    (* if Hashtbl.length context.layers_microlevel = 0 *)

    Draw_macrolevel.draw_treemap_rectangle ~cr ~color:(Some "DarkSlateGray") 
      ~alpha tr;
    (* draw a thin rectangle with aspect color *)
    CairoH.draw_rectangle_bis ~cr ~color:(tr.T.tr_color) 
      ~line_width:(font_size / 2.) tr.T.tr_rect;
  end;

  (* highlighting layers (and grep-like queries at one point) *)
  let hmatching_lines = 
    try Hashtbl.find context.layers_microlevel file
    with Not_found -> Hashtbl.create 0
  in
  (* todo: make sgrep_query a form of layer *)
  let matching_grep_lines = 
    try Hashtbl.find_all context.grep_query file
    with Not_found -> []
  in
  matching_grep_lines +> List.iter (fun line ->
    Hashtbl.add hmatching_lines line "purple"
  );

  let glyphs_opt = glyphs_of_file ~context ~font_size ~font_size_real file in
  glyphs_opt +> Common.do_option (fun glyphs ->
    glyphs +> Array.iteri (fun line glyph ->
      let lc = line_to_line_in_column line layout in
      let x, y = line_in_column_to_bottom_pos lc r layout in
      Cairo.move_to cr x y;
      
      glyphs.(line) +> List.iter (fun glyph ->
        Cairo.set_font_size cr glyph.M.font_size;
        let (r,g,b) = Color.rgbf_of_string glyph.color in
        let alpha = 1. in
        (* old:
         *   if CairoH.is_old_cairo () then
         *     match () with
         *     | _ when final_font_size_real < 1. -> 0.2
         *     | _ when final_font_size_real < 3. -> 0.4
         *     | _ when final_font_size_real < 5. -> 0.9
         *         
         *     | _ when final_font_size_real < 8. 
         *           -> 1. (* TODO - alpha_adjust, do that only when not in
         *                    fully zoomed mode *)
         *     | _ -> 1.
         *   else 1.
         *)
        Cairo.set_source_rgba cr r g b alpha;
        CairoH.show_text cr glyph.M.str;
      );
      
      (* still? must be done before the move_to below ! *)
      (match Common2.hfind_option line hmatching_lines with
      | None -> ()
      | Some color ->
        CairoH.fill_rectangle ~cr 
          ~alpha:0.25
          ~color
          ~x 
          ~y:(y - layout.height_per_line) 
          ~w:layout.width_per_column 
          ~h:(layout.height_per_line * 3.)
          ()
      );
    );
  );

  { line_to_rectangle = 
      (fun line -> line_to_rectangle line r layout);
    pos_to_line = 
      (fun pt -> point_to_line pt r layout);
    layout;
    container = tr;
    content = glyphs_opt;
  }

let draw_content ~cr ~layout ~context tr =
  Common.profile_code "View.draw_content" (fun () ->
    draw_content2 ~cr ~layout ~context tr)
@


<<draw_treemap_rectangle_content_maybe>>=
let draw_treemap_rectangle_content_maybe2 ~cr ~clipping ~context tr  =
  let r = tr.T.tr_rect in

  if F.intersection_rectangles r clipping = None
  then (* pr2 ("not drawing: " ^ file) *) None
  else begin

    let file = tr.T.tr_label in

    (* if the file is not textual, or contain weird characters, then
     * it confuses cairo which then can confuse computation done in gtk
     * idle callbacks
     *)
    if Common2.lfile_exists_eff file && File_type.is_textual_file file
    then begin
      let w = F.rect_width r in
      let h = F.rect_height r in

      let font_size_estimate = h / 100. in
      let font_size_real_estimate = 
        CairoH.user_to_device_font_size cr font_size_estimate in
      if font_size_real_estimate > 0.4
      then begin
        
       (* Common.nblines_with_wc was really slow. Forking sucks.
        * alt: we could store the nblines of a file in the db.
        *)
        let nblines = Common2.nblines_eff file +> float_of_int in
        
       (* Assume our code follow certain conventions. Could infer from file. 
        * We should put 80, but a font is higher than large, so I 
        * manually readjust things.
        *)
        let chars_per_column = 41.0 in
    
        let split_nb_columns = 
          optimal_nb_columns ~nblines ~chars_per_column ~h ~w in
        let font_size = 
          font_size_when_have_x_columns ~nblines ~chars_per_column ~h ~w 
            ~with_n_columns:split_nb_columns in

        let layout = {
          nblines;
          lfont_size = font_size;
          split_nb_columns;
          width_per_column = w / split_nb_columns;
          height_per_line = font_size;
          nblines_per_column = (nblines / split_nb_columns) +> ceil;
        } 
        in
        
        draw_column_bars ~cr layout r;
        
       (* todo: does not work :(
          let font_option = Cairo.Font_Options.make [`ANTIALIAS_SUBPIXEL] in
       
       (try 
         Cairo.set_font_options cr font_option;
       with exn ->
         let status = Cairo.status cr in
         let s2 = Cairo.string_of_status status in
         failwith s2;
       );
       *)
        Cairo.select_font_face cr Style.font_text
          Cairo.FONT_SLANT_NORMAL Cairo.FONT_WEIGHT_NORMAL;
    
        let font_size_real = CairoH.user_to_device_font_size cr font_size in
       (*pr2 (spf "file: %s, font_size_real = %f" file font_size_real);*)
    
        if font_size_real > !Flag.threshold_draw_content_font_size_real 
            && not (is_big_file_with_few_lines ~nblines file)
            && nblines < !Flag.threshold_draw_content_nblines
        then Some (draw_content ~cr ~layout ~context tr)
        else 
          if context.settings.draw_summary 
            (* draw_summary_content ~cr ~layout ~context tr *)
          then raise Todo
          else None
      end
      else None
    end
    else None
  end
let draw_treemap_rectangle_content_maybe ~cr ~clipping ~context rect = 
  Common.profile_code "View.draw_content_maybe" (fun () ->
    draw_treemap_rectangle_content_maybe2 ~cr ~clipping ~context rect)
@ 

\subsection{Color code}



\section{Macro+Micro View}

\subsection{Painting}

% also contain the code for calling the micro-level

<<paint>>=

let paint_content_maybe_rect ~user_rect dw rect =
  let cr = Cairo_lablgtk.create dw.pm#pixmap in
  zoom_pan_scale_map cr dw;

  let context = M.context_of_drawing dw in

  let pos_and_line_opt = 
    Draw_microlevel.draw_treemap_rectangle_content_maybe
      ~cr  ~clipping:user_rect  ~context rect in
  pos_and_line_opt +> Common.do_option (fun pos_and_line ->
    Hashtbl.replace dw.microlevel rect pos_and_line
  );

  (* have to redraw the label *)
  Draw_labels.draw_treemap_rectangle_label_maybe 
    ~cr ~zoom:dw.zoom ~color:None rect;

  ()

(* todo: deadlock:  M.locked (fun () ->  ) dw.M.model.M.m *)
let lazy_paint ~user_rect dw () =
  pr2 "Lazy Paint";
  let start = Unix.gettimeofday () in
  while Unix.gettimeofday () - start < 0.3 do
    match !Ctl.current_rects_to_draw with
    | [] -> ()
    | x::xs ->
        Ctl.current_rects_to_draw := xs;
        pr2 (spf "Drawing: %s" (x.T.tr_label));
        paint_content_maybe_rect ~user_rect dw x;
  done;
  !Ctl._refresh_da ();
  if !Ctl.current_rects_to_draw = []
  then false
  else true


let paint2 dw = 

  !Ctl.paint_content_maybe_refresher +> Common.do_option GMain.Idle.remove;
  Ctl.current_rects_to_draw := [];

  let cr = Cairo_lablgtk.create dw.pm#pixmap in
  dw.pm#rectangle 
    ~x:0 ~y:0 
    ~width:dw.width ~height:dw.height 
    ~filled:true () ;

  pr2 (spf "paint, with zoom = %f, xtrans = %f, ytrans = %f" 
          dw.zoom dw.xtrans dw.ytrans);
  let user_rect = device_to_user_area dw in
  pr2 (F.s_of_rectangle user_rect);

  zoom_pan_scale_map cr dw;

  let rects = dw.treemap in
  let nb_rects = dw.nb_rects in

  (if not (Layer_code.has_active_layers dw.layers)
  then
    (* phase 1, draw the rectangles *)
    rects +> List.iter (Draw_macrolevel.draw_treemap_rectangle ~cr)
  else 
    rects +> List.iter (Draw_macrolevel.draw_trect_using_layers ~cr dw.layers)
  );

  (* phase 2, draw the labels, if have enough space *)
  rects +> List.iter (Draw_labels.draw_treemap_rectangle_label_maybe 
                         ~cr ~zoom:dw.zoom  ~color:None);

  (* phase 3, draw the content, if have enough space *)
  if not dw.in_dragging && nb_rects < !Flag.threshold_nb_rects_draw_content
    (* draw_content_maybe calls nblines which is quite expensive so
     * want to limit it *)
  then begin
    Ctl.current_rects_to_draw := rects;
    Ctl.paint_content_maybe_refresher := 
      Some (Gui.gmain_idle_add ~prio:3000 (lazy_paint ~user_rect dw));
  end;

  (* also clear the overlay *)
  let cr_overlay = Cairo.create dw.overlay in
  CairoH.clear cr_overlay;

  ()

let paint dw = 
  Common.profile_code "View.paint" (fun () -> paint2 dw)
@ 



\subsection{Mixed view}

<<draw_summary_content>>=
(* todo: should base this on the current max in the current view.
 * Also bad that can not compare function use by just looking
 * at their size :(
*)
let threshold_print_summary_entity_users = 10

let draw_summary_content2 ~cr ~w_per_column ~context ~nblines ~file rect =

  let r = rect.T.tr_rect in
  let file = rect.T.tr_label in

  let model = Async.async_get context.model in

  let files_entities = model.Model2.hfiles_entities in
  let entities = 
    try Hashtbl.find files_entities file
    with Not_found -> []
  in
  let entities = 
    entities 
    +> Common.take_safe 5
    +> List.filter (fun e ->
      e.Db.e_number_external_users > threshold_print_summary_entity_users
    )
  in

  let _w = F.rect_width r in
  let h = F.rect_height r in

  (* todo: bad to use w cos its give advantage to huge file.
   * w_per_column on the opposite is rougly the same on a screen.
   *)
  let font_size = w_per_column / 2. in

  let font_size_real = CairoH.user_to_device_font_size cr font_size in
  
  let space_per_line_summary = 
    h / 6.
  in
  entities +> Common.index_list_1 +> List.iter (fun (e, i) ->

    let nb_use = e.Db.e_number_external_users in
    (* todo: move this func elsewhere, in database_code ?  *)
    let use_arity = Parsing.use_arity_of_use_count nb_use in
    
    (* would like to reuse code used when drawing content but
     * I've copy paste to allow specifics anamorphic config
     *)
    let font_size_multiplier = 
      (* should reuse Style2.mulitplier_use ? *)
      match use_arity with
      | HC.HugeUse when nb_use > 1000 -> 4.
      | HC.HugeUse -> 3.
      | HC.LotsOfUse -> 2.
      | HC.MultiUse -> 1.1
      | HC.SomeUse | HC.UniqueUse -> 0.7
      | HC.NoUse -> 0.5
    in
    let size_font_multiplier_multiplier = 
      (*- 0.2 * font_size_real + 2. *)
      match font_size_real with
      | n when n < 3. -> 2.
      | n when n < 8. -> 1.5
      | n when n < 10. -> 1.
      | _ -> 0.5
    in

    let final_font_size = 
      Draw_common.final_font_size_when_multiplier 
        ~multiplier:font_size_multiplier
        ~size_font_multiplier_multiplier
        ~font_size
        ~font_size_real
    in

  (* TODO use the appropriate color for entity *)
    (let (r,g,b) = 
      0.2, 0.0, 0.0
    in
    let alpha = 0.5 in
    Cairo.set_source_rgba cr r g b alpha;
    );
    Cairo.set_font_size cr final_font_size;
    
    let x = r.p.x in
    let y = r.p.y + (space_per_line_summary * (float_of_int i)) in

    let str = e.Db.e_name in
    Cairo.move_to cr x y;
    CairoH.show_text cr str;
    let str = spf "(%d)" e.Db.e_number_external_users in
    CairoH.show_text cr str;
  );
  ()

let draw_summary_content 
 ~cr ~w_per_column ~context ~nblines ~file rect =
  Common.profile_code "View.draw_summary_content" (fun () ->
    draw_summary_content2 ~cr ~w_per_column ~context ~nblines ~file rect)
@ 


<<hfiles_and_top_entities sig>>=
val hfiles_and_top_entities :
  Common.path -> Database_code.database option -> 
  (Common.filename, Database_code.entity list) Hashtbl.t
@

<<hfiles_and_top_entities()>>=
(* used in the summary mixed mode *)
let hfiles_and_top_entities root db_opt =
  let hfiles = Hashtbl.create 1001 in

  db_opt +> Common.do_option (fun db ->
    let ksorted = 
      Db.build_top_k_sorted_entities_per_file ~k:5 db.Db.entities in
    let actual_root = actual_root_of_db ~root db in

    Hashtbl.iter (fun k v ->
      let k' = Filename.concat actual_root k in
      Hashtbl.add hfiles k' v
    ) ksorted
  );
  hfiles
@

<<model fields hook>>=
hfiles_entities : (Common.filename, Database_code.entity list) Hashtbl.t;
@ 

\section{Layers}

\subsection{Micro-level}

\begin{verbatim}
This is kind of intra-file "aspect"
\end{verbatim}

\subsection{Macro-level}

% need majority when multiple match same file ?

\begin{verbatim}
This is kind of inter-file "aspect". See also
the regular archi_code treemap which is also
about aspects.
\end{verbatim}

\subsection{UI}

<<ui_layers.mli>>=
val choose_layer: 
  root:Common.dirname ->
  string option (* layer title we want *) -> 
  Model2.drawing ref -> 
  unit
@ 

<<ui_layers.ml>>=
<<Facebook copyright>>
open Common

open Model2
module M = Model2
module Controller = Controller2

module L = Layer_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

let choose_layer ~root layer_title_opt dw_ref =
  pr2 "choose_layer()";
  let dw = !dw_ref in

  let original_layers = dw.M.layers.L.layers +> List.map fst in
  let layers_idx = 
    Layer_code.build_index_of_layers 
      ~root
      (original_layers +> List.map (fun layer ->
        layer, 
        match layer_title_opt with
        | None -> false
        | Some title -> title =$= layer.L.title
      ))
  in
  dw_ref := 
    Model2.init_drawing 
      ~width:dw.width
      ~height:dw.height
      ~width_minimap:dw.width_minimap
      ~height_minimap:dw.height_minimap
      dw.treemap_func 
      dw.dw_model 
      layers_idx
      [root]
      root;
  View_mainmap.paint !dw_ref;
  !Controller._refresh_da ();
  !Controller._refresh_legend ();
  ()

@ 


\section{Navigation}

<<key_pressed>>=
let key_pressed (da, da2) dw_ref ev = 
  let dw = !dw_ref in

  pr2 ("key pressed");

  (* this is in device coordinate, so no need to take into account the zoom *)
  let _delta_move = float dw.width /. 16. in
  let delta_move_user = 0.1 in (* TODO *)

  let delta_zoom = 1.3 in

  let b = 
    (match GdkEvent.Key.keyval ev with
    | k when k = K._Left ->
        dw.xtrans <- dw.xtrans +. delta_move_user;
        (* todo opti: *)
        paint dw;
        true
    | k when k = K._Right ->
        dw.xtrans <- dw.xtrans -. delta_move_user;
        (* todo opti: *)
        paint dw;
        true

    | k when k = K._Up ->
        dw.ytrans <- dw.ytrans +. delta_move_user;
        (* todo opti: *)
        paint dw;
        true
    | k when k = K._Down ->
        dw.ytrans <- dw.ytrans -. delta_move_user;
        (* todo opti: *)
        paint dw;
        true

    | k when k = K._plus ->
        dw.zoom <- dw.zoom /. delta_zoom;
        (* can't optimize here, have to paint *)
        paint dw;
        true
    | k when k = K._minus ->
        dw.zoom <- dw.zoom *. delta_zoom;
        (* can't optimize here, have to paint *)
        paint dw;
        true




    | k when k = K._z ->
        dw.in_zoom_incruste <- not (dw.in_zoom_incruste);
        true

    | k when k = K._b ->
        !Ctl._go_back dw_ref;
        true

    | k when k = K._e ->
        raise Todo

    | k when k = K._q ->
        GMain.quit () ; false

    | _ -> false
    )
  in
  if b then begin
    GtkBase.Widget.queue_draw da#as_widget;
    GtkBase.Widget.queue_draw da2#as_widget;
  end;
  b
@ 


<<find_filepos_in_rectangle_at_user_point>>=
@ 

<<text_with_user_pos sig>>=
@ 


<<button_action>>=
let button_action da dw_ref ev =
  let dw = !dw_ref in

  let x, y = GdkEvent.Button.x ev, GdkEvent.Button.y ev in
  let pt = { Cairo. x = x; y = y } in
  let user = with_map dw (fun cr -> Cairo.device_to_user cr pt) in
  let r_opt = M.find_rectangle_at_user_point dw user in

  match GdkEvent.get_type ev with
  | `BUTTON_PRESS ->
      let button = GdkEvent.Button.button ev in
      let state = GdkEvent.Button.state ev in
      pr2 (spf "button %d pressed" button);
      (match button with
      | 1 -> 
        (* DISABLED FOR NOW
         * dw.drag_pt <- { 
         * Cairo.x = GdkEvent.Button.x ev; 
         * Cairo.y = GdkEvent.Button.y ev; 
         * };
         * dw.in_dragging <- true;
         *)
        r_opt +> Common.do_option (fun (r, _, _r_englobing) ->
          let file = r.T.tr_label in
          pr2 (spf "clicking on %s" file);
        );
        true
      | 2 ->
        r_opt +> Common.do_option (fun (r, _, _r_englobing) ->
          let file = r.T.tr_label in
          pr2 (spf "opening %s" file);
          let line =
            match M.find_line_in_rectangle_at_user_point dw user r with
            | None -> 1
            (* emacs line numbers start at 1 *)
            | Some l -> l +.. 1
          in
          Editor_connection.open_file_in_current_editor ~file ~line;
        );
        true

      | 3 ->

        r_opt +> Common.do_option (fun (r, _, _r_englobing) ->
          let file = r.T.tr_label in

          if not (Gdk.Convert.test_modifier `SHIFT state)
          then !Ctl._go_dirs_or_file dw_ref [file]
          else begin

          (* similar to View_overlays.motion.refresher *)
          let entity_opt =
            if Hashtbl.mem dw.microlevel r
            then
              let translate = Hashtbl.find dw.microlevel r in
              let line = translate.pos_to_line user in
              M.find_entity_at_line line r dw
            else None
          in

          
          let uses, users = 
            match entity_opt with
            | None -> M.uses_and_users_readable_files_of_file file dw
            | Some n -> M.uses_and_users_readable_files_of_node n dw
          in

          let model = Async.async_get dw.dw_model in
          let paths_of_readables xs = 
            xs 
            +> List.sort Pervasives.compare
            +> Common2.uniq
            (* todo: tfidf to filter files like common2.ml *)
            +> Common.exclude (fun readable -> 
              readable =~ "commons/.*" || 
              readable =~ "external/.*" 
            )
            +> List.map (fun s -> Filename.concat model.root s)
          in

          let readable = Common.filename_without_leading_path model.root file in

          GToolbox.popup_menu ~entries:[
            `I ("go to file", (fun () -> 
              !Ctl._go_dirs_or_file dw_ref (paths_of_readables [readable]);));
            `I ("deps inout", (fun () -> 
              !Ctl._go_dirs_or_file dw_ref (paths_of_readables 
                                              (uses ++ users ++ [readable]))));
            `I ("deps in (users)", (fun () -> 
              !Ctl._go_dirs_or_file dw_ref (paths_of_readables 
                                              (users ++ [readable]))));
            `I ("deps out (uses)", (fun () -> 
              !Ctl._go_dirs_or_file dw_ref (paths_of_readables 
                                            (uses ++ [readable]))));
          ] ~button:3 ~time:(GtkMain.Main.get_current_event_time());
          end
        );
        true
      | _ -> false
      )
  | `BUTTON_RELEASE ->

      let button = GdkEvent.Button.button ev in
      pr2 (spf "button %d released" button);

      (match button with
      | 1 ->
          dw.in_dragging <- false;

          GtkBase.Widget.queue_draw da#as_widget;
          true
      | _ -> false
      )

  | `TWO_BUTTON_PRESS ->
      pr2 ("double click");

      r_opt +> Common.do_option (fun (_r, _, r_englobing) ->
        let path = r_englobing.T.tr_label in
        !Ctl._go_dirs_or_file dw_ref [path];
      );

      true
  | _ -> false
@ 



\subsection{Zooming in a directory}


<<go_dirs_or_file>>=
let go_dirs_or_file ?(current_entity=None) ?(current_grep_query=None) 
  dw_ref paths =

  let root = Common2.common_prefix_of_files_or_dirs paths in
  pr2 (spf "zooming in %s" (Common.join "|" paths));

  (* reset the painter ? not needed because will call draw below
   * which will reset it
   *)

  let dw = !dw_ref in
  !Controller._set_title (Controller.title_of_path root);

  (* the release event will arrive later on the new dw so
   * has to first set the context good for the old dw
   *)
  !dw_ref.in_dragging <- false;
  
  Common.push2 !dw_ref Controller.dw_stack;
  let root = (Async.async_get dw.dw_model).root in

  dw_ref := 
    Model2.init_drawing 
      ~width:dw.width
      ~height:dw.height
      ~width_minimap:dw.width_minimap
      ~height_minimap:dw.height_minimap
      dw.treemap_func 
      dw.dw_model 
      dw.layers
      paths
      root;
  !dw_ref.current_entity <- current_entity;
  (match current_grep_query with
  | Some h ->
      !dw_ref.current_grep_query <- h;
  | None ->
      (* wants to propagate the query so when right-click the query
       * is still there
       *)
      !dw_ref.current_grep_query <- dw.current_grep_query;
  );
  View_mainmap.paint !dw_ref;
  !Controller._refresh_da ();
  ()
@ 


<<find_rectangle_at_user_point sig>>=
val find_rectangle_at_user_point :
  drawing ->
  Cairo.point ->
  (Treemap.treemap_rectangle * (* most precise *)
   Treemap.treemap_rectangle list * (* englobbing ones *)
   Treemap.treemap_rectangle (* top one *)
  ) option
@

<<find_rectangle_at_user_point()>>=
(* alt: could use Cairo_bigarray and the pixel trick below if
 * it takes too long to detect which rectangle is under the cursor.
 * coud also sort the rectangles ... or have some kind of BSP.
 * 
 * going from a point to the enclosing rectangle via pixel color trick. 
 * Kind of ugly. Add this in the model:
 *   mutable pm_color_trick: GDraw.pixmap;
 *   mutable pm_color_trick_info: (string) array.
 * 
 * Current solution: just find pixel by iterating over all the rectangles
 * and check if he's inside.
 *)
let find_rectangle_at_user_point2 dw user =
  let user = CairoH.cairo_point_to_point user in

  let rects = dw.treemap in
  if List.length rects = 1
  then 
    (* we are fully zommed, this treemap will have tr_depth = 1 but we return
     * it *)
    let x = List.hd rects in
    Some (x, [], x)
  else 
   let matching_rects = rects 
    +> List.filter (fun r -> 
      F.point_is_in_rectangle user r.T.tr_rect
      && r.T.tr_depth > 1
    ) 
    +> List.map (fun r -> r, r.T.tr_depth) 
    (* opti: this should be far faster by using a quad tree to represent
     * the treemap
     *)
    +> Common.sort_by_val_highfirst 
    +> List.map fst
   in
   match matching_rects with
   | [] -> None
   | [x] -> Some (x, [], x)
   | _ -> Some (Common2.head_middle_tail matching_rects)

let find_rectangle_at_user_point a b = 
  Common.profile_code "Model.find_rectangle_at_point" (fun () ->
    find_rectangle_at_user_point2 a b)
@

\subsection{Zooming in multiple directories}

\begin{verbatim}
see multi dir search
\end{verbatim}

\subsection{Zooming in a file}

\subsection{Opening a file in an external editor}

<<editor_connection.mli>>=
val open_file_in_current_editor : file:string -> line:int -> unit
@ 

<<emacs configuration>>=
let emacsclient_path_mac =
  "/home/pad/Dropbox/apps/Emacs.app/Contents/MacOS/bin/emacsclient"

let emacsclient_path = "emacsclient"

(* you need to have done a M-x server-start first *)
let run_emacsclient ~file ~line =
  Common.command2 (spf "%s -n %s" emacsclient_path file);
  Common.command2 (spf 
    "%s -e '(with-current-buffer (window-buffer (selected-window)) (goto-line %d))'"
    emacsclient_path line);
  ()
@


<<open_file_in_current_editor()>>=
let open_file_in_current_editor ~file ~line =
  run_emacsclient ~file ~line
@


\subsection{Going back}

<<go_back>>=
let go_back dw_ref = 

  (* reset also the motion notifier ? less needed because
   * the next motion will reset it
   *)
  !Controller.paint_content_maybe_refresher +> Common.do_option (fun x ->
    GMain.Idle.remove x;
  );

  let old_dw = Common2.pop2 Controller.dw_stack in
  dw_ref := old_dw;
  
  let path = !dw_ref.current_root in
  !Controller._set_title (Controller.title_of_path path);

  !Controller._refresh_da();
  ()
@ 

\subsection{Magnifying glass}

%Incruste Mode

<<idle>>=
let idle dw () = 
  let dw = !dw in

  (*pr2 "idle";*)
  !Controller.current_r +> Common.do_option (fun r ->
    (* will compute and cache *)
    if dw.in_zoom_incruste 
    then zoomed_surface_of_rectangle dw r +> ignore;
  );
  true
@ 


\subsection{Minimap}


<<motion_notify_minimap>>=
let motion_notify_minimap (da, da2) dw ev =
  let dw = !dw in

  let x = GdkEvent.Motion.x ev in
  let y = GdkEvent.Motion.y ev in
  pr2 ("motion minimap");

  if dw.in_dragging then begin

    let deltax = x -. dw.drag_pt_minimap.Cairo.x in
    let deltay = y -. dw.drag_pt_minimap.Cairo.y in

    let deltax_user = 
      with_minimap dw (fun cr -> CairoH.device_to_user_distance_x cr deltax)
    in
    let deltay_user = 
      with_minimap dw (fun cr -> CairoH.device_to_user_distance_y cr deltay)
    in
    dw.xtrans <- dw.xtrans -. deltax_user;
    dw.ytrans <- dw.ytrans -. deltay_user;
    
  
    (* pr2_gen (deltax, deltay); *)
    dw.drag_pt_minimap <- { Cairo.x = x ; Cairo.y = y } ;
    
    (* TODO: opti, should not recompute when just move! *)
(* TOREPUT
    paint dw;
*)

    GtkBase.Widget.queue_draw da#as_widget;
    GtkBase.Widget.queue_draw da2#as_widget;
    
    true
  end else begin
    true
  end
@ 


<<button_action_minimap>>=
let button_action_minimap (da,da2) dw ev =
  let dw = !dw in

  match GdkEvent.get_type ev with
  | `BUTTON_PRESS ->
      pr2 ("button pressed minimap");

      dw.drag_pt_minimap <- { 
        Cairo.x = GdkEvent.Button.x ev ; 
        Cairo.y = GdkEvent.Button.y ev 
      };
      dw.in_dragging <- true;

      true

  | `BUTTON_RELEASE ->
      pr2 ("button released minimap");
      dw.in_dragging <- false;

      (* TODO: opti *)
(* TOREPUT
      paint dw;
*)

      GtkBase.Widget.queue_draw da#as_widget;
      GtkBase.Widget.queue_draw da2#as_widget;
      true
  | _ -> false
@ 


<<paint_minimap>>=
let paint_minimap2 dw = 
  let cr = Cairo_lablgtk.create dw.pm_minimap#pixmap in
  dw.pm_minimap#rectangle 
    ~x:0 ~y:0 
    ~width:dw.width_minimap ~height:dw.height_minimap
    ~filled:true () ;

  scale_minimap cr dw;

  let rects = dw.treemap in
  (* draw the rectangles *)
  rects +> List.iter (Draw_macrolevel.draw_treemap_rectangle ~cr);

  (* draw the labels, if have enough space *)
  rects +> List.iter 
    (Draw_labels.draw_treemap_rectangle_label_maybe ~cr ~zoom:1.0 ~color:None);

  (* draw the zoom rectangle *)
  let user_rect = 
    (* device_to_user_area dw  *)
     raise Todo
  in
  CairoH.draw_rectangle_figure ~cr ~color:"white" user_rect;
  ()


let paint_minimap dw = 
  Common.profile_code "View.paint minimap" (fun () -> paint_minimap2 dw)
@ 


<<expose_minimap>>=
let expose_minimap da dw_ref ev = 
  let dw = !dw_ref in

  (* todo? opti? don't paint if not needed ? *)
  (*paint_minimap dw;*)

  let area = GdkEvent.Expose.area ev in
  let x = GR.x area in
  let y = GR.y area in
  let width = GR.width area in
  let height = GR.height area in

  let gwin = da#misc#window in
  let d = new GDraw.drawable gwin in

  Common.profile_code "View.put_pixmap mini" (fun () ->
    d#put_pixmap ~x ~y ~xsrc:x ~ysrc:y ~width ~height 
      dw.pm_minimap#pixmap;
  );
  true
@ 


<<configure_minimap>>=
let configure_minimap da2 dw_ref ev = 
  let dw = !dw_ref in

  let w = GdkEvent.Configure.width ev in
  let h = GdkEvent.Configure.height ev in
  dw.width_minimap <- w;
  dw.height_minimap <- h;
  dw.pm_minimap <- new_pixmap dw.width_minimap dw.height_minimap;
  true
@ 


<<with_minimap>>=
let with_minimap dw f =
  let cr = Cairo_lablgtk.create dw.pm_minimap#pixmap in
  scale_minimap cr dw;
  f cr
@ 

<<fields drawing minimap>>=
  (* minimap *)
  mutable pm_minimap: GDraw.pixmap;
  mutable width_minimap: int;
  mutable height_minimap: int;

  mutable drag_pt_minimap: Cairo.point;
@

<<scale_minimap>>=
let scale_minimap cr dw =
  (* no zoom, no pan, no clippnig *)
  Cairo.translate cr 0.0 0.0;
  Cairo.scale cr 
    (1.0 * (float_of_int dw.width_minimap / T.xy_ratio))
    (1.0 * (float_of_int dw.height_minimap))
@ 


\subsection{Fine-grained pan and zoom}


<<with_map>>=
let with_map dw f = 
  let cr = Cairo_lablgtk.create dw.pm#pixmap in
  zoom_pan_scale_map cr dw;
  f cr
@ 

<<zoom_pan_scale_map>>=
let zoom_pan_scale_map cr dw =
  Cairo.scale cr 
    (dw.zoom * (float_of_int dw.width / T.xy_ratio))
    (dw.zoom * (float_of_int dw.height))
  ;
  (* I first scale and then translate as the xtrans are in user coordinates *)
  Cairo.translate cr dw.xtrans dw.ytrans;
  (* TODO clipping  Cairo.rectangle cr ~x:dw.xtrans ~y: *)
  ()
@ 

<<fields drawing viewport>>=
  (* viewport, device coordinates *)
  mutable width: int;
  mutable height: int;

  (* to delete? *)
  mutable zoom: float;
  (* in user coordinates *)
  mutable xtrans: float;
  mutable ytrans: float;

  mutable drag_pt: Cairo.point;
  mutable in_dragging: bool;

  mutable in_zoom_incruste: bool;
@

\section{Search}

<<dialog_search_def>>=
let dialog_search_def model = 
  let idx = (fun () -> 
    let model = Async.async_get model in
    model.Model2.big_grep_idx 
  )
  in
  let entry = 
    Completion2.my_entry_completion_eff 
      ~callback_selected:(fun entry str file e ->
        true
      )
      ~callback_changed:(fun str ->
        ()
      )
      idx
  in

  let res =
    G.dialog_ask_generic ~title:"" 
      (fun vbox -> 
        vbox#pack (G.with_label "search:" entry#coerce);
      )
      (fun () -> 
        let text = entry#text in 
        pr2 text;
        text
      )
  in
  res +> Common.do_option (fun s -> 
    pr2 ("selected: " ^ s);
  );
  res
@ 


<<run_grep_query>>=
let run_grep_query ~root s =
  (* --cached so faster ? use -w ?  
   * -I means no search for binary files
   * -n to show also line number
   *)
  let git_grep_options = 
    "-I -n"
  in
  let cmd = 
    spf "cd %s; git grep %s %s" root git_grep_options s
  in
  let xs = Common.cmd_to_list cmd in
  let xs = xs +> List.map (fun s ->
    if s =~ "\\([^:]*\\):\\([0-9]+\\):.*"
    then
      let (filename, lineno) = Common.matched2 s in
      let lineno = s_to_i lineno in
      let fullpath = Filename.concat root filename in
      fullpath, lineno
    else 
      failwith ("wrong git grep line: " ^ s)
  ) in
  xs
@ 


<<run_tbgs_query>>=
let run_tbgs_query ~root s =
  let cmd = 
    spf "cd %s; tbgs --stripdir %s" root s
  in
  let xs = Common.cmd_to_list cmd in
  let xs = xs +> List.map (fun s ->
    if s =~ "\\([^:]*\\):\\([0-9]+\\):.*"
    then
      let (filename, lineno) = Common.matched2 s in
      let lineno = s_to_i lineno in
      let fullpath = Filename.concat root filename in
      fullpath, lineno
    else 
      failwith ("wrong tbgs line: " ^ s)
  ) in
  xs
@ 



<<fields drawing query stuff>>=
  (* queries *)
  mutable current_query: string;
  mutable current_searched_rectangles: Treemap.treemap_rectangle list;
  mutable current_entity: Database_code.entity option;
  mutable current_grep_query: (Common.filename, int) Hashtbl.t;
@

\subsection{Definition search}

\begin{verbatim}
%tags-like

% php manual integration!
\end{verbatim}



<<all_entities sig>>=
(* Will generate extra entities for files, dirs, and also generate
 * an extra entity when have a fullname that is not empty
 *)
val all_entities :
  Database_code.database option -> Common.dirname ->
  Database_code.entity list
@



\subsubsection{Completion building}

<<completion2.mli>>=

val build_completion_defs_index : 
  Database_code.entity list -> Big_grep.index
@ 

<<build_completion_defs_index>>=
(* I was previously using a prefix-clustering optimisation but it
 * does not allow suffix search. Moreover it was still slow so
 * big_grep is just simpler and better.
 *)

let build_completion_defs_index all_entities = 
  (* todo? compute stuff in background ?
   *  Thread.create (fun () -> 
   * while(true) do 
   * Thread.delay 4.0;
   * pr2 "thread1";
   * done
   * ) ();
   *)
  BG.build_index all_entities
@ 

\subsubsection{Completion window}

<<completion2.mli>>=

val my_entry_completion_eff :
  callback_selected:
   (GEdit.entry -> string -> string -> Database_code.entity -> bool) ->
  callback_changed:(string -> unit) -> 
  (unit -> Big_grep.index) ->
  GEdit.entry
@ 

<<model fields hook>>=
big_grep_idx: Big_grep.index;
@ 

\begin{verbatim}
%tags-like

% for func/class/methods/ files and dirs!
\end{verbatim}


<<all_entities>>=
(* We want to provide completion not only for functions/class/methods
 * but also for files and directory themselves.
 * 
 * We pass the root in addition to the db_opt because sometimes we 
 * don't have a db but we still want to provide completion for the 
 * dirs and files.
 * 
 * todo: what do do when the root of the db is not the root
 * of the treemap ?
 *)
let all_entities db_opt root =
  match db_opt with
  | None -> 
      let db = Database_code.files_and_dirs_database_from_root root in
      Database_code.files_and_dirs_and_sorted_entities_for_completion
        ~threshold_too_many_entities:!Flag.threshold_too_many_entities
        db

  | Some db ->
      let nb_entities = Array.length db.Db.entities in
      let nb_files = List.length db.Db.files in
      pr2 (spf "We got %d entities in %d files" nb_entities nb_files);

      Database_code.files_and_dirs_and_sorted_entities_for_completion
        ~threshold_too_many_entities:!Flag.threshold_too_many_entities
        db
@




<<completion2.ml>>=
<<Facebook copyright>>
open Common

module G = Gui

module Db = Database_code
module BG = Big_grep

module Flag = Flag_visual

(* to optimize the completion by using a specialized fast ocaml-based model *)
open Custom_list_generic

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * Gtk is quite "fragile". You change what looks to be an innoncent line
 * and then suddenly your performance goes down or you get some
 * gtk warnings at runtime. So take care when changing this file.
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let is_prefix2 s1 s2 =
  (String.length s1 <= String.length s2) && 
  (String.sub s2 0 (String.length s1) = s1)
let is_prefix a b = 
  Common.profile_code "Completion.is_prefix" (fun () -> is_prefix2 a b)


(*****************************************************************************)
(*  *)
(*****************************************************************************)

<<build_completion_defs_index>>


(*****************************************************************************)
(* Model *)
(*****************************************************************************)

let icon_of_kind kind has_test =
  match kind with
  | Db.Function -> 
      if has_test then `YES else `NO
  
  (* todo: do different symbols for unit tested class and methods ? 
   * or add another column in completion popup
   * todo? class vs interface ?
   *)
  | Db.Class _ -> `CONNECT
  | Db.Module -> `DISCONNECT
  | Db.Package -> `DIRECTORY
  | Db.Type -> `PROPERTIES
  | Db.Constant -> `CONNECT
  | Db.Global -> `MEDIA_RECORD
  | Db.Method Db.RegularMethod -> `CONVERT
  | Db.Method Db.StaticMethod -> `EXECUTE

  | Db.File -> `FILE
  | Db.Dir -> `DIRECTORY
  | Db.MultiDirs -> `QUIT

  (* todo *)
  | Db.Field -> `CONNECT
  | Db.Macro -> `CONNECT
  | Db.Exception -> `CONNECT
  | Db.Constructor -> `CONNECT
  | Db.Prototype -> `CONNECT
  | Db.GlobalExtern -> `CONNECT

  | (Db.TopStmts | Db.Other _ | Db.ClassConstant) -> raise Todo


module L=struct
  type t = { 
    mutable entity: Database_code.entity;
    mutable text: string; 
    mutable file: string; 
    mutable count: string;
    mutable kind: string;
    mutable icon: GtkStock.id;
  }

  (** The columns in our custom model *)
  let column_list = new GTree.column_list ;;
  let col_full = (column_list#add Gobject.Data.caml: t GTree.column);;

  let col_text = column_list#add Gobject.Data.string;;
  let col_file = column_list#add Gobject.Data.string;;
  let col_count = column_list#add Gobject.Data.string;;
  let col_kind = column_list#add Gobject.Data.string;;
  let col_icon = column_list#add GtkStock.conv;;

  let custom_value _ t ~column = 
    match column with
    | 0 -> (* col_full *) `CAML (Obj.repr t)

    | 1 -> (* col_text *) `STRING (Some t.text)
    | 2 -> (* col_file *) `STRING (Some t.file)
    | 3 -> (* col_count *) `STRING (Some t.count)
    | 4 -> (* col_kind *) `STRING (Some t.kind)

    (* pad: big hack, they use STRING to present stockid in gtkStock.ml *) 
    | 5 -> (* col_icon *) `STRING (Some (GtkStock.convert_id t.icon))
    | _ -> assert false

end

module MODEL=MAKE(L)

let model_of_list_pair_string_with_icon2 query xs =

  let custom_list = MODEL.custom_list () in

  pr2 (spf "Size of model = %d" (List.length xs));
  xs +> List.iter (fun e ->
    let kind = e.Db.e_kind in
    
    let has_unit_test =
      List.length e.Db.e_good_examples_of_use >= 1
    in
    let name = e.Db.e_name in
    custom_list#insert {L. 
      entity = e;                     

      (* had originally an ugly hack where we would artificially create
       * a text2 field with always set to query. Indeed
       * gtk seems to be confused if the column referenced
       * by set_text_column contains a string that is not matching
       * the current query. So here we were building this fake text entry.
       * In fact as explained on the pygtk entry of entry_completion
       * you don't have to use set_text_column if you provide
       * your own set_match_func, which we do.
       * Maybe we should just not use Entrycompletion at all and build
       * our own popup.
       *)
      text = name;


      file = e.Db.e_file;
      count = i_to_s (e.Db.e_number_external_users);
      kind = Db.string_of_entity_kind kind;
      icon = icon_of_kind kind has_unit_test;
    };
  );
  (custom_list :> GTree.model)


let model_of_list_pair_string_with_icon query a =
  Common.profile_code "Completion2.model_of_list" (fun () ->
    model_of_list_pair_string_with_icon2 query a
  )

let model_col_of_prefix prefix_or_suffix idx =
  let xs = 
    BG.top_n_search 
      ~top_n:!Flag.top_n
      ~query:prefix_or_suffix idx
  in
  model_of_list_pair_string_with_icon prefix_or_suffix xs

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

let add_renderer (completion : GEdit.entry_completion) =

  let renderer = 
    GTree.cell_renderer_pixbuf [ `STOCK_SIZE `BUTTON ] in
  completion#pack (renderer :> GTree.cell_renderer);
  completion#add_attribute (renderer :> GTree.cell_renderer) 
    "stock_id" L.col_icon;

  let renderer = GTree.cell_renderer_text [] in
  completion#pack (renderer :> GTree.cell_renderer);
  completion#add_attribute (renderer :> GTree.cell_renderer) 
    "text" L.col_text;

  let renderer = GTree.cell_renderer_text [] in
  completion#pack (renderer :> GTree.cell_renderer);
  completion#add_attribute (renderer :> GTree.cell_renderer) 
    "text" L.col_count;

  let renderer = GTree.cell_renderer_text [] in
  completion#pack (renderer :> GTree.cell_renderer);
  completion#add_attribute (renderer :> GTree.cell_renderer) 
    "text" L.col_file;

  (* can omit this:
   *    completion#set_text_column L.col_text2; 
   * 
   * but then must define a set_match_func otherwise will never
   * see a popup
   *)
  ()

let fake_entity = {Database_code.
     e_name = "foobar";
     e_fullname = "";
     e_file = "foo.php";
     e_kind = Db.Function;
     e_pos = { Common2.l = -1; c = -1 };
     e_number_external_users = 0;
     e_good_examples_of_use = [];
     e_properties = [];
}

let my_entry_completion_eff2 ~callback_selected ~callback_changed fn_idx = 
  
  let entry = GEdit.entry ~width:900 () in
  let completion = GEdit.entry_completion () in
  entry#set_completion completion;

  let xs = [ fake_entity ] in
  let model_dumb = model_of_list_pair_string_with_icon "foo" xs in
  let model = ref (model_dumb) in

  add_renderer completion;
  completion#set_model (!model :> GTree.model);

  (* we don't use the builtin gtk completion mechanism as we
   * recompute the model each time using big_grep so where
   * we just always return true. Moreover the builtin gtk
   * function would do a is_prefix check between the row
   * and the current query which in our case would fail when
   * we use the suffix-search ability of big_grep.
   *)
  completion#set_match_func (fun key row ->
    true
  );
  completion#set_minimum_key_length 2;

  completion#connect#match_selected (fun model_filter row ->
     (* note: the code below does not work; the row is relative to the
      * model_filter.
      * let str = !model#get ~row ~column:col1 in
      * let file = !model#get ~row ~column:col2 in
      *)

      let str = 
        model_filter#child_model#get 
          ~row:(model_filter#convert_iter_to_child_iter row)
          ~column:L.col_text
      in
      let file = 
        model_filter#child_model#get 
          ~row:(model_filter#convert_iter_to_child_iter row)
          ~column:L.col_file
      in
      let t = 
        model_filter#child_model#get 
          ~row:(model_filter#convert_iter_to_child_iter row)
          ~column:L.col_full
      in
      callback_selected entry str file t.L.entity
  ) +> ignore;

  let current_timeout = ref None in

  entry#connect#changed (fun () -> 
    let s = entry#text in
    pr2 s;
    if s <> "" then begin
      !current_timeout +> Common.do_option (fun x ->
        GMain.Timeout.remove x;
      );
      current_timeout :=
        Some 
          (GMain.Timeout.add ~ms:250
           ~callback:(fun _ -> 

            pr2 "changing model";
            let idx = fn_idx () in
            model := model_col_of_prefix s idx;
            completion#set_model (!model :> GTree.model);

            callback_changed s;
            false
          ));
    end
    else callback_changed s
  ) +> ignore;

  (* return the entry so someone can hook another signal *)
  entry
 
let my_entry_completion_eff ~callback_selected ~callback_changed x = 
  my_entry_completion_eff2 ~callback_selected ~callback_changed x


@ 

\subsection{Use Search, aka Visual [[grep]]}


\begin{verbatim}
%cscope-like
% see also layers
\end{verbatim}


\subsection{Directory search}

\begin{verbatim}
%multi dirs
\end{verbatim}

\subsection{Multi-directories}

\subsection{Example search}

\begin{verbatim}
%test search

% pleac integration!
\end{verbatim}


\section{Overlays}

% draw vs paint vs xxx

\subsection{Cairo overlays}

\begin{verbatim}
aka layers
similar but different from the  layers in prevision section.
Here low level graphics layers.
\end{verbatim}

<<fields drawing main view>>=
  (* device coordinates *)
  mutable pm: GDraw.pixmap;
  mutable overlay: [ `Any ] Cairo.surface;

@

\subsection{Rectangle overlay}

<<draw_rectangle_overlay>>=
let draw_englobing_rectangles_overlay ~dw (r, middle, r_englobing) =
 with_overlay dw (fun cr_overlay ->
  CairoH.draw_rectangle_figure 
    ~cr:cr_overlay ~color:"white" r.T.tr_rect;
  CairoH.draw_rectangle_figure
    ~cr:cr_overlay ~color:"blue" r_englobing.T.tr_rect;

  Draw_labels.draw_treemap_rectangle_label_maybe 
    ~cr:cr_overlay ~color:(Some "red") ~zoom:dw.zoom r_englobing;

  middle +> Common.index_list_1 +> List.iter (fun (r, i) ->
    let color = 
      match i with
      | 1 -> "grey70"
      | 2 -> "grey40"
      | _ -> spf "grey%d" (max 1 (50 -.. (i *.. 10)))
    in
    CairoH.draw_rectangle_figure
      ~cr:cr_overlay ~color r.T.tr_rect;
    Draw_labels.draw_treemap_rectangle_label_maybe 
      ~cr:cr_overlay ~color:(Some color) ~zoom:dw.zoom r;
  );
 )
@ 


\subsection{Label overlay}

<<draw_label_overlay>>=
(* assumes cr_overlay has not been zoom_pan_scale *)
let draw_label_overlay ~cr_overlay ~dw ~x ~y txt =

  Cairo.select_font_face cr_overlay "serif" 
    Cairo.FONT_SLANT_NORMAL Cairo.FONT_WEIGHT_NORMAL;
  Cairo.set_font_size cr_overlay Style2.font_size_filename_cursor;
      
  let extent = CairoH.text_extents cr_overlay txt in
  let tw = extent.Cairo.text_width in
  let th = extent.Cairo.text_height in

  let refx = x - tw / 2. in
  let refy = y in

  CairoH.fill_rectangle ~cr:cr_overlay 
    ~x:(refx + extent.Cairo.x_bearing) ~y:(refy + extent.Cairo.y_bearing)
    ~w:tw ~h:(th * 1.2)
    ~color:"black"
    ~alpha:0.5
    ();

  Cairo.move_to cr_overlay refx refy;
  Cairo.set_source_rgba cr_overlay 1. 1. 1.    1.0;
  CairoH.show_text cr_overlay txt;
  
  (*
  Cairo.set_source_rgb cr_overlay 0.3 0.3 0.3;
  Cairo.move_to cr_overlay x y;
  Cairo.line_to cr_overlay (x + 10.) (y + 10.);
  Cairo.stroke cr_overlay;
  *)
  ()
@ 

\subsection{Searched files overlay}

<<draw_searched_rectangles>>=
let draw_searched_rectangles ~dw =
 with_overlay dw (fun cr_overlay ->
  dw.current_searched_rectangles +> List.iter (fun r ->
    CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"yellow" r.T.tr_rect
  );
  (* 
   * would also like to draw not matching rectangles
   * bug the following code is too slow on huge treemaps. 
   * Probably because it is doing lots of drawing and alpha
   * computation.
   *
   * old:
   * let color = Some "grey3" in
   * Draw.draw_treemap_rectangle ~cr:cr_overlay 
   * ~color ~alpha:0.3
   * r
   *)
 )
@ 

\subsection{Zoom overlay}

<<zoomed_surface_of_rectangle>>=
let _hmemo_surface = Hashtbl.create 101
let zoomed_surface_of_rectangle dw r =
  Common.memoized _hmemo_surface (r.T.tr_label, dw.zoom) (fun () ->

  let user_rect = View_mainmap.device_to_user_area dw in
  
  let sur =
    Cairo.surface_create_similar (CairoH.surface_of_pixmap dw.pm)
      (* subtle: can not use dw.width or dw.height here because at
       * the zoom level we will proceed, the whole file would probably not
       * feel on the full screen. If it does not fit, then having a too
       * small surface mean parts of the rendering of the file will not
       * be stored.
       *)
      Cairo.CONTENT_COLOR_ALPHA 9000 9000;
  in
  let cr = Cairo.create sur in

  (* simplify the drawing context, draw on 0 x 0 a rectangle that itself
   * starts at 0 x 0
   *)
  let dw' = { dw with 
    zoom = dw.zoom * Style.zoom_factor_incruste_mode; (* CONFIG *)
    xtrans = 0.; ytrans = 0.;
  } 
  in
  View_mainmap.zoom_pan_scale_map cr dw';
  (* a normalized rectangle that starts at 0 x 0 *)
  let rect = r.T.tr_rect in
  let rect' = { 
    F.p = { F. x = 0.; y = 0.;};
    F.q = { F. x = F.rect_width rect; y = F.rect_height rect;};
  }
  in
  let r' = { r with T.tr_rect = rect' } in

  let user_width = F.rect_width rect in
  let user_height = F.rect_height rect in

  let device_width  = CairoH.user_to_device_distance_x cr user_width in
  let device_height = CairoH.user_to_device_distance_y cr user_height in
  (* now have on the surface the same thing we would have got if we had
   * zoomed a lot.
   *)

  let context = context_of_drawing dw in
  let context = { context with Model2.nb_rects_on_screen = 1 } in

  Draw_macrolevel.draw_treemap_rectangle 
    ~cr ~alpha:0.9 r';
  let _pos_and_file_TODO = 
    Draw_microlevel.draw_treemap_rectangle_content_maybe 
      ~cr ~context ~clipping:user_rect r' in

  sur, device_width, device_height
  )



let draw_zoomed_overlay ~cr_overlay ~user ~dw ~x ~y r =

  let percent_x = 
    (user.Cairo.x - r.T.tr_rect.p.F.x) / F.rect_width r.T.tr_rect in
  let percent_y = 
    (user.Cairo.y - r.T.tr_rect.p.F.y) / F.rect_height r.T.tr_rect in
  
  let zoomed_surface, zoomed_device_width, zoomed_device_height = 
    zoomed_surface_of_rectangle dw r
  in
  Cairo.set_operator cr_overlay Cairo.OPERATOR_OVER;
  (* old:
     Cairo.set_source_surface cr_overlay zoomed_surface (x - 100.) (y - 100.);
     Cairo.paint cr_overlay;
  *)
  (* see http://cairographics.org/FAQ/#paint_from_a_surface *)
  let dest_x = (x + 20.) in
  let dest_y = (y + 20.) in
  let width = float_of_int dw.width / 2.5 in
  let height = float_of_int dw.height / 2.5 in
  let source_x = 
    Common2.borne
      ~min:0. ~max:(zoomed_device_width - width)
      ((percent_x * zoomed_device_width) - 140.)
  in
  let source_y = 
    Common2.borne
      ~min:0. ~max:(zoomed_device_height - height)
      ((percent_y * zoomed_device_height) - 30.)
  in

  pr2 (spf "at x%%= %.3f, y%% = %.3f, zoom_w = %.3f, zoom_h = %.3f" 
          percent_x percent_y
          zoomed_device_width
          zoomed_device_height
  );

  Cairo.set_source_surface cr_overlay zoomed_surface
    (dest_x -. source_x) (dest_y -. source_y);
  Cairo.rectangle cr_overlay dest_x dest_y width height;
  Cairo.fill cr_overlay;
  ()
@ 

\subsection{Assembling overlays}

<<motion_refresher>>=
let motion_refresher ev dw () =
  let cr_overlay = Cairo.create dw.overlay in
  CairoH.clear cr_overlay;

  (* some similarity with View_mainmap.button_action handler *)
  let x, y = GdkEvent.Motion.x ev, GdkEvent.Motion.y ev in
  let pt = { Cairo. x = x; y = y } in
  let user = View_mainmap.with_map dw (fun cr -> Cairo.device_to_user cr pt) in
  let r_opt = M.find_rectangle_at_user_point dw user in

  r_opt +> Common.do_option (fun (r, middle, r_englobing) ->
    let line_opt, entity_opt =
      if Hashtbl.mem dw.microlevel r
      then
        let microlevel = Hashtbl.find dw.microlevel r in
        let line = microlevel.pos_to_line user in
        let entity_opt = M.find_entity_at_line line r dw in
        Some line, entity_opt
      else None, None
    in

    let statusbar_txt = 
      r.T.tr_label ^
      (match line_opt with None -> "" | Some i -> spf ":%d" i) ^
      (match entity_opt with None -> "" | Some n -> 
        " (" ^ Graph_code.string_of_node n ^ ")"
      )
    in
    !Controller._statusbar_addtext statusbar_txt;

    (match line_opt with
    | None ->
      let label_txt = readable_txt_for_label r.T.tr_label dw.current_root in
      draw_label_overlay ~cr_overlay ~dw ~x ~y label_txt
    | Some line ->
       let microlevel = Hashtbl.find dw.microlevel r in
       draw_magnify_line_overlay_maybe dw line microlevel
    );

    draw_englobing_rectangles_overlay ~dw (r, middle, r_englobing);

    draw_uses_users_files ~dw r;

    (match line_opt, entity_opt with
    | Some line, Some n ->
      let microlevel = Hashtbl.find dw.microlevel r in
      let rectangle = microlevel.line_to_rectangle line in
      with_overlay dw (fun cr ->
        CairoH.draw_rectangle_figure ~cr ~color:"white" rectangle
      );
      draw_uses_users_entities ~dw n;
    | _ -> ()
    );
     
    if dw.dw_settings.draw_searched_rectangles;
    then draw_searched_rectangles ~dw;
    
    Controller.current_r := Some r;
    
    (* it has been computed, use it then *)
    if Hashtbl.mem _hmemo_surface (r.T.tr_label, dw.zoom) &&
       dw.in_zoom_incruste
    then draw_zoomed_overlay ~cr_overlay ~user ~dw ~x ~y r;
  );
  !Controller._refresh_da ();
  false


let motion_notify (da, da2) dw ev =
  !Controller.current_motion_refresher +> Common.do_option (fun x ->
    GMain.Idle.remove x;
  );

  let dw = !dw in

  let x, y = GdkEvent.Motion.x ev, GdkEvent.Motion.y ev in
  pr2 (spf "motion: %f, %f" x y);

  if dw.in_dragging then begin

    let deltax = x -. dw.drag_pt.Cairo.x in
    let deltay = y -. dw.drag_pt.Cairo.y in
    
    let deltax_user = 
      View_mainmap.with_map dw 
        (fun cr -> CairoH.device_to_user_distance_x cr deltax)
    in
    let deltay_user = 
      View_mainmap.with_map dw 
        (fun cr -> CairoH.device_to_user_distance_y cr deltay)
    in
    
    dw.xtrans <- dw.xtrans +. deltax_user;
    dw.ytrans <- dw.ytrans +. deltay_user;
    
    dw.drag_pt <- { Cairo.x = x ; Cairo.y = y } ;
    
    GtkBase.Widget.queue_draw da#as_widget;
    GtkBase.Widget.queue_draw da2#as_widget;
  
    true
  end else begin
    Controller.current_motion_refresher := 
      Some (Gui.gmain_idle_add ~prio:100 (motion_refresher ev dw));
    true
  end
@ 


\section{Final Rendering}

\subsection{The big picture}

\begin{verbatim}

\end{verbatim}


\subsection{The [[configure]] event}

<<configure>>=
let configure2_bis da dw_ref ev = 
  let dw = !dw_ref in

  let w = GdkEvent.Configure.width ev in
  let h = GdkEvent.Configure.height ev in

  dw.width <- w;
  dw.height <- h;
  dw.pm <- Model2.new_pixmap dw.width dw.height;
  dw.overlay <- 
    Cairo.surface_create_similar (CairoH.surface_of_pixmap dw.pm)
    Cairo.CONTENT_COLOR_ALPHA w h;
    
  View_mainmap.paint dw;
  true

(* ugly: for some unknown reason configure get called twice at
 * the beginning of the program
 *)
let first_call = ref true
let configure2 a b c =
  (* should probably do is_old_gtk() *)
  if !first_call && CairoH.is_old_cairo () 
  then begin first_call := false; true end
  else 
    configure2_bis a b c

let configure a b c =
  Common.profile_code "View.configure" (fun () -> configure2 a b c)
@ 


\subsection{The [[expose]] event}

<<assemble_layers>>=
(* Composing the "layers". See cairo/tests/knockout.ml example.
 * Each move of the cursor will call assemble_layers which does all
 * those pixels copying (which is very fast).
 * 
 * The final target is the actual gtk window which is represented by cr_final.
 * We copy the pixels from the pixmap dw.pm on the window. Then
 * we copy the pixels from the pixmap dw.overlay on the windown
 * getting the final result.
 *)
let assemble_layers cr_final dw ~width ~height =

  let surface_src = CairoH.surface_of_pixmap dw.pm in

  Cairo.set_operator cr_final Cairo.OPERATOR_OVER;
  Cairo.set_source_surface cr_final surface_src 0. 0.;
  Cairo.paint cr_final;

  Cairo.set_operator cr_final Cairo.OPERATOR_OVER;
  Cairo.set_source_surface cr_final dw.overlay 0. 0.;
  Cairo.paint cr_final;
  ()
@ 


<<expose>>=
let expose2 da dw_ref ev = 
  let dw = !dw_ref in

  (* opti: don't 'paint dw;' if not needed! painting is the computation
   * heavy function. expose just copy the "canvas" layers  
   *)

  (* todo? equivalent to   
   *  let allocation = d_area#misc#allocation in
   * allocation.Gtk.width allocation.Gtk.height
   * ?
   *)
  let area = GdkEvent.Expose.area ev in
  let width = GR.width area +> float_of_int in
  let height = GR.height area +> float_of_int in
  (* todo? use ? it can optimise things ? *)
  let _x = GR.x area in
  let _y = GR.y area in

  let gwin = da#misc#window in
  let cr = Cairo_lablgtk.create gwin in
  assemble_layers cr dw ~width ~height;
  (* old:
  Common.profile_code "View.put_pixmap" (fun () ->
    let d = new GDraw.drawable gwin in
    d#put_pixmap ~x ~y ~xsrc:x ~ysrc:y ~width ~height dw.pm#pixmap;
  );
  *)
  true

let expose a b c = 
  Common.profile_code "View.expose" (fun () -> expose2 a b c)
@ 


\subsection{Trace: clicking a directory}

\begin{verbatim}
diagram where see events, functions,  draw vs paint vs overlays.
\end{verbatim}

\subsection{Trace: moving the mouse}

\begin{verbatim}
diagram where see events, functions,  draw vs paint vs overlays.
\end{verbatim}


\section{Language Modes}

\subsection{Parsing}

<<parsing2.mli>>=

(* internally memoize the parsing part in _hmemo_file *)
val tokens_with_categ_of_file:
  Common.filename ->
  (string, Database_code.entity) Hashtbl.t ->
  (string * Highlight_code.category option * Common2.filepos) list

val disable_file_in_cache: 
  Common.filename -> unit

(* helpers *)
val use_arity_of_use_count: 
  int -> Highlight_code.use_arity

@ 


\subsection{Generic semantic visual feedback}

<<parsing2.ml>>=
<<Facebook copyright>>
open Common

module FT = File_type
module PI = Parse_info
module HC = Highlight_code
module Db = Database_code
module Flag = Flag_visual

open Highlight_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * The main entry point of this module is tokens_with_categ_of_file
 * which is called in Draw_microlevel to "render" the content of a file.
 *)

(*****************************************************************************)
(* Parsing helpers *)
(*****************************************************************************)

(* This type is needed if we want to use a single hashtbl to memoize
 * all the parsed file. Having a single hash helps for 
 * disable_file_in_cache below.
 *)
type ast = 
  | ML  of Parse_ml.program_and_tokens
  | Hs  of Parse_hs.program2

  | Html of Parse_html.program2
  | Js  of Parse_js.program_and_tokens
  | Php of Parse_php.program_with_comments

  | Opa of Parse_opa.program_with_tokens

  | Cpp of Parse_cpp.program2

  | Csharp of Parse_csharp.program_and_tokens
  | Java of Parse_java.program2

  | Lisp of Parse_lisp.program2
  | Erlang of Parse_erlang.program2

  | Python of Parse_python.program2

  | Noweb of Parse_nw.program2

  (* less? | Org of Org_mode.org ? *)

let _hmemo_file = Hashtbl.create 101

(* This is useful when we want to refresh the content of a file,
 * because it has changed on the disk. 
 * todo? could also look at the date of the file ...
 *)
let disable_file_in_cache file =
  Hashtbl.remove _hmemo_file file

let parse_cache parse_in extract file =
  Common.profile_code "View.parse_cache" (fun () ->
    let ast = Common.memoized _hmemo_file file (fun () -> parse_in file) in
    extract ast
  )

(*****************************************************************************)
(* Semantic ehancement *)
(*****************************************************************************)

let use_arity_of_use_count n =
  match () with
  (* note that because my PHP object analysis have some threshold
   * on the number of callers (see threshold_callers_indirect_db)
   * the number for HugeUse can not be more than this one otherwise
   * you will miss some cases
   *)
  | _ when n >= 100 -> HugeUse
  | _ when n > 20   -> LotsOfUse
  | _ when n >= 10  -> MultiUse
  | _ when n >= 2   -> SomeUse
  | _ when n = 1    -> UniqueUse
  | _               -> NoUse

let rewrite_categ_using_entities s categ file entities =

  let e_kind_opt = 
    try Some (Db.entity_kind_of_highlight_category_def categ)
    with _ -> None
  in
  match e_kind_opt with
  | None -> categ
  | Some e_kind ->

   let entities = 
    Hashtbl.find_all entities s +> List.filter (fun e ->
      (* we could have the full www dbcode but run the treemap on
       * a subdir in which case the root will not be the same.
       * It's a good approximation to just look at the basename.
       * The only false positive we will get if another file,
       * with the same name happened to also define entities
       * with the same name, which would be rare.
       * 
       * update: TODO use Model2.readable_to_absolute_filename_under_root ?
       *)
      Filename.basename e.Db.e_file =$= Filename.basename file &&
      (* some file have both a function and class with the same name *)
      e.Db.e_kind =*= e_kind
    )
  in
  match entities with
  | [] -> categ
  | [e] ->
      let use_cnt = e.Db.e_number_external_users in
      let arity = use_arity_of_use_count use_cnt in
      if HC.is_entity_def_category categ
      then HC.rewrap_arity_def2_category arity categ 
      else categ
  | x::y::xs ->
      (* TODO: handle __construct directly *)
      if not (List.mem s ["__construct"])
      then
        pr2_once (spf "multi def found for %s in %s" s file);
      categ

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
type ('ast, 'token) for_helper = {
  parse: (string -> ('ast * 'token list) list);
  highlight_visit:(tag_hook:(Parse_info.info -> HC.category -> unit) ->
                   Highlight_code.highlighter_preferences ->
                   'ast * 'token list -> unit);
  info_of_tok:('token -> Parse_info.info);
  str_of_tok:('token -> string);
}

let tokens_with_categ_of_file_helper {parse;highlight_visit;
  info_of_tok;str_of_tok} file prefs hentities =
  
  let h = Hashtbl.create 101 in
  if !Flag.verbose_visual then pr2 (spf "Parsing: %s" file);
  let ast2 = parse file in

  if !Flag.verbose_visual then pr2 (spf "Highlighting: %s" file);
  ast2 +> List.map (fun (ast, toks) ->

    (* computing the token attributes *)
    highlight_visit ~tag_hook:(fun info categ -> Hashtbl.add h info categ)
      prefs (ast, toks);

    (* getting the text *)
    toks +> Common.map_filter (fun tok -> 
      let info = info_of_tok tok in
      let s = str_of_tok tok in
      if not (Parse_info.is_origintok info)
      then None
      else 
        let categ = Common2.hfind_option info h +> Common2.fmap (fun categ ->
          rewrite_categ_using_entities s categ file hentities
        ) in
        Some (s, categ,{ Common2.l = PI.line_of_info info; c = PI.col_of_info info; })
    )) +> List.flatten

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

(* coupling: right now if you add a language here, you need to whitelist it
 * also in draw_microlevel.draw_contents2.
 *)
let tokens_with_categ_of_file file hentities = 
  let ftype = FT.file_type_of_file file in
  let prefs = Highlight_code.default_highlighter_preferences in
  
  match ftype with
  | FT.PL (FT.Web (FT.Php _)) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache (fun file ->
          Common.save_excursion Flag_parsing_php.error_recovery true (fun () ->
            let ((ast, toks), stat) = Parse_php.parse file in
            (* todo: use database_light if given? we could so that
             * variables are better annotated.
             * note that database_light will be passed in
             * rewrite_categ_using_entities() at least.
             *)
            let find_entity = None in
            (* work by side effect on ast2 too *)
            Check_variables_php.check_and_annotate_program
              find_entity
              ast;
            Php ((ast, toks))
          ))
         (function Php (ast, toks) -> [ast, toks] | _ -> raise Impossible));
         highlight_visit = (fun ~tag_hook prefs (ast, toks) ->
          Highlight_php.visit_program ~tag:tag_hook prefs hentities 
            (ast, toks)
         );
         info_of_tok = Token_helpers_php.info_of_tok;
         str_of_tok = Token_helpers_php.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.ML _) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache (fun file -> 
           Common.save_excursion Flag_parsing_ml.error_recovery true (fun()->
             ML (Parse_ml.parse file +> fst))
         )
         (function ML (ast, toks) -> [ast, toks] | _ -> raise Impossible));
        highlight_visit = (fun ~tag_hook prefs (ast, toks) -> 
          Highlight_ml.visit_program ~tag_hook prefs (ast, toks));
        info_of_tok = Token_helpers_ml.info_of_tok;
        str_of_tok = Token_helpers_ml.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Haskell _) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Hs (Parse_hs.parse file +> fst))
         (function Hs x -> x | _ -> raise Impossible));
        highlight_visit = (fun ~tag_hook prefs (ast, toks) -> 
          Highlight_hs.visit_toplevel ~tag_hook prefs (ast, toks));
        info_of_tok = Parser_hs.info_of_tok;
        str_of_tok = Parser_hs.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Python) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Python (Parse_python.parse file +> fst))
         (function Python x -> x | _ -> raise Impossible));
        highlight_visit = (fun ~tag_hook prefs (ast, toks) -> 
          Highlight_python.visit_toplevel ~tag_hook prefs (ast, toks));
        info_of_tok = Token_helpers_python.info_of_tok;
        str_of_tok = Token_helpers_python.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Csharp) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Csharp (Parse_csharp.parse file +> fst))
         (function Csharp (ast, toks) -> [ast, toks] | _ -> raise Impossible));
        highlight_visit = (fun ~tag_hook prefs (ast, toks) -> 
          Highlight_csharp.visit_program ~tag_hook prefs (ast, toks));
        info_of_tok = Token_helpers_csharp.info_of_tok;
        str_of_tok = Token_helpers_csharp.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Opa) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Opa (Parse_opa.parse_just_tokens file))
         (function 
         | Opa (ast, toks) -> [ast, toks] 
         | _ -> raise Impossible));
        highlight_visit = Highlight_opa.visit_toplevel;
        info_of_tok = Token_helpers_opa.info_of_tok;
        str_of_tok = Token_helpers_opa.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Erlang) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Erlang (Parse_erlang.parse file +> fst))
         (function Erlang x -> x | _ -> raise Impossible));
        highlight_visit = Highlight_erlang.visit_toplevel;
        info_of_tok = Token_helpers_erlang.info_of_tok;
        str_of_tok = Token_helpers_erlang.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Java) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Java (Parse_java.parse file +> fst))
          (function 
          | Java (ast, toks) -> [Common2.some ast, (toks)] 
          | _ -> raise Impossible));
        highlight_visit = Highlight_java.visit_toplevel;
        info_of_tok = Token_helpers_java.info_of_tok;
        str_of_tok = Token_helpers_java.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Lisp _) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Lisp (Parse_lisp.parse file +> fst))
         (function Lisp x -> x | _ -> raise Impossible));
        highlight_visit = Highlight_lisp.visit_toplevel;
        info_of_tok = Parser_lisp.info_of_tok;
        str_of_tok = Parser_lisp.str_of_tok;
        }
        file prefs hentities

  | FT.Text ("nw" | "tex" | "texi" | "web") ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Noweb (Parse_nw.parse file +> fst))
         (function Noweb x -> x | _ -> raise Impossible));
        highlight_visit = Highlight_nw.visit_toplevel;
        info_of_tok = Token_helpers_nw.info_of_tok;
        str_of_tok = Token_helpers_nw.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Cplusplus _ | FT.C _ | FT.Thrift) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> 
           let (ast2, stat) = Parse_cpp.parse file in
           let ast = Parse_cpp.program_of_program2 ast2 in
           (* work by side effect on ast2 too *)
           Check_variables_cpp.check_and_annotate_program
             ast;
           Cpp ast2
         )
         (function Cpp x -> x | _ -> raise Impossible));
        highlight_visit = Highlight_cpp.visit_toplevel;
        info_of_tok = Token_helpers_cpp.info_of_tok;
        str_of_tok = Token_helpers_cpp.str_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Web (FT.Js)) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache
          (fun file -> 
            Common.save_excursion Flag_parsing_js.error_recovery true (fun () ->
              Js (Parse_js.parse file +> fst))
          )
         (function Js (ast, toks) -> [ast, toks] | _ -> raise Impossible));
        highlight_visit = Highlight_js.visit_program;
        info_of_tok = Token_helpers_js.info_of_tok;
        str_of_tok = (fun tok -> 
          let s = Token_helpers_js.str_of_tok tok in
          Ast_js.remove_quotes_if_present s
        );
        }
        file prefs hentities

  | FT.PL (FT.Web (FT.Html)) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
          (fun file -> Html (Parse_html.parse file))
          (function 
          | Html (ast, toks) -> [ast, toks] 
          | _ -> raise Impossible));
        highlight_visit = Highlight_html.visit_toplevel;
        info_of_tok = Token_helpers_html.info_of_tok;
        str_of_tok = Token_helpers_html.str_of_tok;
        }
        file prefs hentities

  | FT.Text ("org") ->
      let org = Org_mode.parse file in
      Org_mode.highlight org

  (* ugly, hardcoded, should instead look at the head of the file for a
   * # -*- org   indication.
   * very pad and code-overlay specific.
   *)
  | FT.Text ("txt") when Common2.basename file =$= "info.txt" ->
      let org = Org_mode.parse file in
      Org_mode.highlight org

  | _ -> failwith 
      "impossible: should be called only when file has good file_kind"
@ 



\subsection{OCaml}

\subsection{Tex/Latex/NoWeb}



\subsection{PHP}

\subsection{Javascript}

\subsection{[[C/C++]] and variants}
%variants: thrift

\subsection{Haskell}

\subsection{Lisp/Scheme}

\section{Optimisations}

\subsection{Threads, Idle, Timeouts}

<<type async>>=
type 'a t = {
  m: Mutex.t; 
  c: Condition.t;
  v: 'a option ref;
  }
@ 

<<async functions sig>>=
val async_get: 'a t -> 'a
val async_make: unit -> 'a t
val async_set: 'a -> 'a t -> unit

val with_lock: (unit -> 'a) -> Mutex.t -> 'a
@

<<async functions>>=
let async_make () = {
  m = Mutex.create (); 
  c = Condition.create ();
  v = ref None;
}

let with_lock f l =
  Mutex.lock l;
  try 
    let x = f () in 
    Mutex.unlock l; 
    x
  with e -> 
    Mutex.unlock l; 
    raise e

let async_get a = 
  let rec go a =
    match !(a.v) with
    | None -> 
        pr2 "not yet computed";
        Condition.wait a.c a.m; 
        go a
    | Some v -> v
  in
  with_lock (fun () -> go a) a.m

let async_set v a = 
  with_lock (fun () ->
    a.v := Some v;
    Condition.signal a.c;
  ) a.m
@ 

\section{Configuration}

<<options>>=
  "-screen_size" , Arg.Set_int screen_size,
  " <int> (1 = small, 2 = big)";
  "-ss" , Arg.Set_int screen_size,
  " alias for -screen_size";
  "-ft", Arg.Set_float Flag.threshold_draw_content_font_size_real,
  " ";
  "-boost_lbl" , Arg.Set Flag.boost_label_size,
  " ";
  "-no_boost_lbl" , Arg.Clear Flag.boost_label_size,
  " ";
  "-no_legend" , Arg.Clear legend,
  " ";

  "-symlinks", Arg.Unit (fun () -> 
    Treemap.follow_symlinks := true;
  ), " ";
  "-no_symlinks", Arg.Unit (fun () ->
    Treemap.follow_symlinks := false;
  ), " ";

  "-with_info", Arg.String (fun s -> db_file := Some s),
  " <db_light_file>";
  "-with_graph", Arg.String (fun s -> graph_file := Some s),
  " <graph_file>";
  "-with_layer", Arg.String (fun s -> layer_file := Some s),
  " <layer_file>";
  "-with_layers", Arg.String (fun s -> layer_dir := Some s),
  " <layer_dir>";

  "-filter", Arg.String (fun s -> filter := List.assoc s filters;), 
   spf " filter certain files (available = %s)" 
    (filters +> List.map fst +> Common.join ", ");

  "-extra_filter", Arg.String (fun s -> Flag.extra_filter := Some s),
  " ";

(*-------------------------------------------------------------------------*)
(* debugging helpers *)
(*-------------------------------------------------------------------------*)

  "-test" , Arg.String (fun s -> test_mode := Some s),
  " <str> execute an internal script";

  "-verbose" , Arg.Set Flag.verbose_visual,
  " ";
  "-debug_gc", Arg.Set Flag.debug_gc,
  " ";
  "-debug_handlers", Arg.Set Gui.synchronous_actions,
  " ";
  (* "-disable_ancient", Arg.Clear Flag.use_ancient, " "; *)
  "-disable_fonts", Arg.Set Flag.disable_fonts,
  " ";
@

<<type settings>>=
 and settings = {
   mutable draw_summary: bool;
   mutable draw_searched_rectangles: bool;
 }
@

<<style2.mli>>=

val windows_params : int -> int * int * int * int

val size_font_multiplier_of_categ :
  font_size_real:float -> Highlight_code.category option -> float

val threshold_draw_dark_background_font_size_real : float

val zoom_factor_incruste_mode : float

val font_size_filename_cursor: float

val font_text: string

@ 

<<windows_params()>>=
let windows_params screen_size =
  let width, height, minimap_hpos, minimap_vpos = 
    match screen_size with
    | 1 ->
        1350, 800, 1100, 150
    | 2 ->
        2560, 1580, 2350, 100 (* was 2200 and 280 *)
    | 3 ->
        7000, 4000, 6900, 100
    | 4 ->
        16000, 9000, 15900, 100
    | 5 ->
        20000, 12000, 19900, 100
    | 6 ->
        25000, 15000, 24900, 100
    | _ ->
        failwith "not valid screen_size"
  in
  width, height, minimap_hpos, minimap_vpos
@


<<size_font_multiplier_of_categ()>>=
let multiplier_use x = 
  match x with
  | SH.HugeUse -> 3.3
  | SH.LotsOfUse -> 2.7
  | SH.MultiUse -> 2.1
  | SH.SomeUse -> 1.7
  | SH.UniqueUse -> 1.3
  | SH.NoUse -> 0.9

let size_font_multiplier_of_categ ~font_size_real categ =
    match categ with

    (* entities defs *)

    | Some (SH.Class SH.Def2 use) -> 5. *. multiplier_use use
    | Some (SH.Module SH.Def) -> 5.
    | Some (SH.Function (SH.Def2 use)) -> 3.5 *. multiplier_use use
    | Some (SH.TypeDef SH.Def) -> 5.
    | Some (SH.Global (SH.Def2 use)) -> 3. *. multiplier_use use
    | Some (SH.FunctionDecl use) -> 2.5 *. multiplier_use use
    | Some (SH.Macro (SH.Def2 use)) -> 2. *. multiplier_use use
    | Some (SH.MacroVar (SH.Def2 use)) -> 2. *. multiplier_use use
    | Some (SH.Method (SH.Def2 use)) -> 3.5 *. multiplier_use use
    | Some (SH.StaticMethod (SH.Def2 use)) -> 3.5 *. multiplier_use use
    | Some (SH.Field (SH.Def2 use)) -> 1.7 *. multiplier_use use

    | Some (SH.ConstructorDef (use)) -> 1.2 *. multiplier_use use

    | Some (SH.GrammarRule) -> 2.5
        
    (* entities uses *)
    | Some (SH.Global (SH.Use2 _)) when font_size_real > 7.
          -> 1.5
(*
    | Some (SH.Method (SH.Use2 _)) when font_size_real > 7.
          -> 1.2
*)
        
    (* "literate programming" *)
    | Some (SH.CommentSection0) -> 5.
    | Some (SH.CommentSection1) -> 3.
    | Some (SH.CommentSection2) -> 2.0
    | Some (SH.CommentSection3) -> 1.2
    | Some (SH.CommentSection4) -> 1.1
    | Some (SH.CommentEstet) -> 1.0
    | Some (SH.CommentCopyright) -> 0.5

    | Some (SH.CommentSyncweb) -> 1.

(*
    | Some (SH.Comment) when font_size_real > 7.
          -> 1.5
*)

    (* semantic visual feedback *)

    | Some (SH.BadSmell) -> 2.5

    (* ocaml *)
    | Some (SH.UseOfRef) -> 2.

    (* php, C, etc *)
    | Some (SH.PointerCall) -> 3.
    | Some (SH.ParameterRef) -> 2.
    | Some (SH.CallByRef) -> 3.

    (* misc *)
    | Some (SH.Local (SH.Def)) -> 1.2
        
    | _ -> 
        (* the cases above should have covered all the cases *)
        categ +> Common.do_option (fun categ ->
          if Highlight_code.is_entity_def_category categ
          then failwith "You should update size_font_multiplier_of_categ";
        );


        1. 
@


<<zoom_factor_incruste_mode>>=
(* TODO: should be automatically computed. Should have instead a
 * wanted_real_font_size_when_incruste_mode = 9.
 *)
let zoom_factor_incruste_mode = 10. (* was 18 *)
@


<<threshold_draw_dark_background_font_size_real>>=
(* CONFIG *)
let threshold_draw_dark_background_font_size_real = 5.
@


<<flag_visual.ml>>=

let verbose_visual = ref false

(* was 0.4, but on linux the anti-aliasing seems to not be as good
 * as on mac (possibly because I have only an old cairo lib on my 
 * Linux machine
 *)
let threshold_draw_content_font_size_real = ref 
  0.6

(* big and auto-generated files can take too much time to render *)
let threshold_draw_content_nblines = 
  ref 25000.

let threshold_draw_label_font_size_real = ref 
  10.

let threshold_nb_rects_draw_content = ref 2500

let threshold_too_many_entities = ref 600000

let top_n = ref 100

let boost_label_size = ref false

let debug_gc = ref false

(* Ancient does not interact well with hashtbl and ocaml polymorphic
 * equality and hash. Have to use a functorized hashtbl which sucks.
 *)
let use_ancient = ref false

let disable_fonts = ref false

let extra_filter = ref (None: string option) (* regexp *)
@ 


\section{Other Features}

<<visual_commitid() action>>=
let test_visual_commitid id =
  let files = Common.cmd_to_list
    (spf "git show --pretty=\"format:\" --name-only %s"
        id) 
    (* not sure why git adds an extra empty line at the beginning but we
     * have to filter it
     *)
    +> Common.exclude Common.null_string
  in
  pr2_gen files;
  main_action files
@

<<actions>>=
  "-test_cairo", " ",
  Common.mk_action_0_arg (test_cairo);
  "-test_commitid", " <id>",
  Common.mk_action_1_arg (test_visual_commitid);
@



\section{Related Work}

\begin{verbatim}

http://www.haskell.org/haskellwiki/Yi

http://www.cse.chalmers.se/~bernardy/FunctionalIncrementalParsing.pdf
"Thanks for the links. The paper is a very interesting reading indeed.
Its main focus is on incrementality (not reparsing the whole buffer at
every keystroke). I'm not so sure how important it is in the context
of the current discussion though: I guess that with an efficient
parsing technology and modern computers, parsing even a big buffer at
every keystroke should be fast enough. Trivial optimizations like
storing the internal state of the parser at some point could also be
used if needed. I'm more concerned about the error recovery aspect;
the paper suggests the use of annotated error recovery rules, but
writing them for a grammar like OCaml's does not seem an easy task at
all." - frish

\end{verbatim}
\section{Conclusion}

Hope you like it.


\appendix

\section{Gtk}

\section{Cairo}

% ref to good tutorial

<<new_pixmap sig>>=
val new_pixmap : 
  width:int -> height:int -> GDraw.pixmap
@

<<new_pixmap()>>=
let new_pixmap ~width ~height =
  let drawable = GDraw.pixmap ~width ~height () in
  drawable#set_foreground `WHITE;
  drawable#rectangle ~x:0 ~y:0 ~width ~height ~filled:true () ;
  drawable
@

<<cairo helpers functions sig>>=
val fill_rectangle:
  ?alpha:float ->
  cr:Cairo.t -> 
  x:float -> y:float -> w:float -> h:float ->
  color:Simple_color.emacs_color -> 
  unit ->
  unit

val draw_rectangle_figure:
  cr:Cairo.t -> 
  color:Simple_color.emacs_color -> 
  Figures.rectangle -> unit

val draw_rectangle_bis:
  cr:Cairo.t -> 
  color:Simple_color.color -> 
  line_width:float ->
  Figures.rectangle -> unit


val prepare_string : string -> string
val origin : Cairo.point

val device_to_user_distance_x : Cairo.t -> float -> float
val device_to_user_distance_y : Cairo.t -> float -> float
val user_to_device_distance_x : Cairo.t -> float -> float
val user_to_device_distance_y : Cairo.t -> float -> float

val device_to_user_size : Cairo.t -> float -> float
val user_to_device_font_size : Cairo.t -> float -> float
val cairo_point_to_point : Cairo.point -> Figures.point

val show_text : Cairo.t -> string -> unit
val text_extents : Cairo.t -> string -> Cairo.text_extents
val set_font_size: Cairo.t -> float -> unit

val clear : Cairo.t -> unit

val surface_of_pixmap :
  < pixmap : [> `drawable ] Gobject.obj; .. > -> [ `Any ] Cairo.surface

val distance_points : Cairo.point -> Cairo.point -> float

val is_old_cairo : unit -> bool
@

<<cairo helpers functions>>=
(* !does side effect on the (mutable) string! *)
let prepare_string s = 
  if s ==~ re_space
  then 
    s ^ s (* double it *)
  else begin
    for i = 0 to String.length s -.. 1 do
      let c = String.get s i in
      if int_of_char c >= 128
      then String.set s i 'Z'
      else 
        if c = '\t'
        then String.set s i ' '
      else ()
    done;
    s
  end


let show_text2 cr s =
  (* this 'if' is only for compatibility with old versions of cairo
   * that returns some out_of_memory error when applied to empty strings
   *)
  if s = "" then () else 
  try 
    let s' = prepare_string s in
    Cairo.show_text cr s'
  with exn ->
    let status = Cairo.status cr in
    let s2 = Cairo.string_of_status status in
    failwith ("Cairo pb: " ^ s2 ^ " s = " ^ s)

let show_text a b = 
  Common.profile_code "View.cairo_show_text" (fun () -> show_text2 a b)

let fake_text_extents = 
  { Cairo.
    x_bearing   = 0.1; y_bearing   = 0.1;
    text_width  = 0.1; text_height = 0.1;
    x_advance   = 0.1; y_advance   = 0.1 ;
  }

let text_extents cr s = 
  Common.profile_code "CairoH.cairo_text_extent" (fun () -> 
    (*if s = ""  then fake_text_extents else *)
    Cairo.text_extents cr s
  )

(* just wrap it here so that we can profile it *)
let set_font_size cr font_size =
  Common.profile_code "CairoH.set_font_size" (fun () ->
    Cairo.set_font_size cr font_size
  )

(*****************************************************************************)
(* Distance conversion *)
(*****************************************************************************)

let origin = { Cairo. x = 0.; y = 0. }

let device_to_user_distance_x cr deltax = 
  let pt = Cairo.device_to_user_distance cr { origin with Cairo.x = deltax } in
  pt.Cairo.x
let device_to_user_distance_y cr deltay = 
  let pt = Cairo.device_to_user_distance cr { origin with Cairo.y = deltay } in
  pt.Cairo.y

let user_to_device_distance_x cr deltax = 
  let pt = Cairo.user_to_device_distance cr { origin with Cairo.x = deltax } in
  pt.Cairo.x
let user_to_device_distance_y cr deltay = 
  let pt = Cairo.user_to_device_distance cr { origin with Cairo.y = deltay } in
  pt.Cairo.y

(* TODO: this is buggy, as we can move the map which can led to
 * some device_to_user to translate to x = 0
 *)
let device_to_user_size cr size = 
  let device = { Cairo.x = size; Cairo.y = 0.; } in
  let user = Cairo.device_to_user cr device in
  user.Cairo.x

(* still needed ? can just call device_to_user_size ? *)
let user_to_device_font_size cr font_size = 
  let user_dist = { Cairo.x = font_size; Cairo.y = font_size } in
  let device_dist = Cairo.user_to_device_distance cr user_dist in
  device_dist.Cairo.x

let cairo_point_to_point p = 
  { F.x = p.Cairo.x;
    F.y = p.Cairo.y;
  }

let distance_points p1 p2 =
  abs_float (p2.Cairo.x - p1.Cairo.x) + 
  abs_float (p2.Cairo.y - p1.Cairo.y)

(*****************************************************************************)
(* Surface *)
(*****************************************************************************)

(* see http://cairographics.org/FAQ/#clear_a_surface *)
let clear cr =
  Cairo.set_source_rgba cr 0. 0. 0.   0.;
  Cairo.set_operator cr Cairo.OPERATOR_SOURCE;
  Cairo.paint cr;
  Cairo.set_operator cr Cairo.OPERATOR_OVER;
  ()

let surface_of_pixmap pm =
  let cr = Cairo_lablgtk.create pm#pixmap in
  Cairo.get_target cr

(*****************************************************************************)
(* Drawing *)
(*****************************************************************************)

let fill_rectangle ?(alpha=1.) ~cr ~x ~y ~w ~h ~color () = 
  (let (r,g,b) = color +> Color.rgbf_of_string in
  Cairo.set_source_rgba cr r g b alpha;
  );
  
  Cairo.move_to cr x y;
  Cairo.line_to cr (x+w) y;
  Cairo.line_to cr (x+w) (y+h);
  Cairo.line_to cr x (y+h);
  Cairo.fill cr;
  ()

let draw_rectangle_figure ~cr ~color r =
  (let (r,g,b) = color +> Color.rgbf_of_string in
  Cairo.set_source_rgb cr r g b;
  );
 let line_width = device_to_user_size cr 3. in

  Cairo.set_line_width cr line_width; (* ((r.q.y - r.p.y) / 30.); *)

  Cairo.move_to cr r.p.x r.p.y;
  Cairo.line_to cr r.q.x r.p.y;
  Cairo.line_to cr r.q.x r.q.y;
  Cairo.line_to cr r.p.x r.q.y;
  Cairo.line_to cr r.p.x r.p.y;
  Cairo.stroke cr;
  ()

(* factorize with draw_rectangle. don't use buggy device_to_user_size !!!
*)
let draw_rectangle_bis ~cr ~color ~line_width r =
  (let (r,g,b) = 
    color +> Color.rgb_of_color +> Color.rgbf_of_rgb
    in
   Cairo.set_source_rgb cr r g b;
  );
  Cairo.set_line_width cr line_width;

  Cairo.move_to cr r.p.x r.p.y;
  Cairo.line_to cr r.q.x r.p.y;
  Cairo.line_to cr r.q.x r.q.y;
  Cairo.line_to cr r.p.x r.q.y;
  Cairo.line_to cr r.p.x r.p.y;
  Cairo.stroke cr;
  ()
@

\paragraph{User vs device coordinates}





\section{Extra Code}

\subsection{[[main_codemap.ml]]}

<<main_codemap.ml>>=
(*
 * Please imagine a long and boring gnu-style copyright notice 
 * appearing just here.
 *)
open Common

module Flag = Flag_visual
module FT = File_type

module Model = Model2

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * This is the main entry point of codemap, a semantic source code visualizer
 * using treemaps and code thumbnails.
 * 
 * requirements:
 *  - get a bird's eye view of all the code (hence treemaps)
 *  - get a bird's eye view of a file (hence code thumbnails)
 *  - better syntax highlighting than Emacs, using real parsers so
 *    we can colorize differently identifiers (a function vs a field vs
 *    a constant etc)
 *  - important code should be bigger. Just like in google maps
 *    the important roads are more visible. So need some sort of
 *    global analysis.
 * 
 * history:
 *  - saw Aspect Browser while working on aspects as an intern at IRISA
 *  - work on Poffs and idea of visualizing the same code through 
 *    different views
 *  - talked about mixing sgrep/spatch with code visualization,
 *    highlighting with a certain color different architecture aspects
 *    of the Linux kernel (influenced by work on aspect browser)
 *  - talked about fancy code visualizer while at cleanmake with YY,
 *    spiros, etc.
 *  - saw SeeSoft code visualizer while doing some bibliographic work
 *  - saw code thumbnails by MSR, and Rob Deline
 *  - saw treemap of Linux kernel by fekete => idea of mixing
 *    tree-map+code-thumbnails+seesoft = codemap
 *  - saw talk at CC about improving javadoc by putting in bigger fonts
 *    really often used API functions => idea of light db and semantic
 *    visual feedback
 * 
 * related work:
 *  - todo: light table
 *  - todo: http://www.kickstarter.com/projects/296054304/zeta-code
 *  - todo? sublime, textmate, etc
 *)

(*****************************************************************************)
(* Flags *)
(*****************************************************************************)

<<main flags>>

let filter = ref Treemap_pl.ex_filter_file

(* less: a config file:
 *  GtkMain.Rc.add_default_file "/home/pad/c-pfff/data/pfff_browser.rc"; 
 *)

(* action mode *)
let action = ref ""

(*****************************************************************************)
(* Shortcuts *)
(*****************************************************************************)

let filters = [
  "ocaml", Treemap_pl.ocaml_filter_file;
  "mli", Treemap_pl.ocaml_mli_filter_file;
  "php", Treemap_pl.php_filter_file;
  "nw", (fun file -> 
    match FT.file_type_of_file file with
    | FT.Text "nw" -> true | _ -> false
  );
  "pfff", (fun file ->
    match FT.file_type_of_file file with
    | FT.PL (
       (FT.ML _) | FT.Makefile | FT.Opa | FT.Prolog _ | FT.Web (FT.Php _))
      -> 
        (* todo: should be done in file_type_of_file *)
        not (FT.is_syncweb_obj_file file)
        && not ( 
                (* file =~ ".*commons/" || *)
                (* file =~ ".*external/" || *)
                file =~ ".*_build/")
    | _ -> false
  );
  "cpp", (let x = ref false in (fun file ->
    Common2.once x (fun () -> Parse_cpp.init_defs !Flag_parsing_cpp.macros_h);
    match FT.file_type_of_file file with
    | FT.PL (FT.C _ | FT.Cplusplus _) -> true 
    | _ -> false
  ));
  "opa", (fun file -> 
    match FT.file_type_of_file file with
    | FT.PL (FT.Opa) (* | FT.PL (FT.ML _) *)  -> true
(*    | FT.PL (FT.Web (_)) -> true *)
    | _ -> false
  );
  "rs", (fun file -> 
    match FT.file_type_of_file file with
    | FT.PL (FT.Rust) -> true
    | _ -> false
  );
]

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let set_gc () =
  if !Flag.debug_gc
  then Gc.set { (Gc.get()) with Gc.verbose = 0x01F };
  (* see http://www.elehack.net/michael/blog/2010/06/ocaml-memory-tuning *)
  Gc.set { (Gc.get()) with Gc.minor_heap_size = 2_000_000 };
  Gc.set { (Gc.get()) with Gc.space_overhead = 200 };
  ()

(*****************************************************************************)
(* Model helpers *)
(*****************************************************************************)

<<treemap_generator>>

<<build_model>>

(* could also try to parse all json files and filter the one which do
 * not parse *)
let layers_in_dir dir =
  Common2.readdir_to_file_list dir +> Common.map_filter (fun file ->
    if file =~ "layer.*json"
    then Some (Filename.concat dir file)
    else None
  )

(*****************************************************************************)
(* Main action *)
(*****************************************************************************)

<<main_action()>>
  
(*****************************************************************************)
(* Extra actions *)
(*****************************************************************************)

<<visual_commitid() action>>

let width = 500
let height = 500

let test_draw cr =
  (* [0,0][1,1] world *)
  Cairo.scale cr (float_of_int width) (float_of_int height);

  Cairo.set_source_rgba cr ~red:0.5 ~green:0.5 ~blue:0.5 ~alpha:0.5;
  Cairo.set_line_width cr 0.001;

  Cairo.move_to cr 0.5 0.5;
  Cairo.line_to cr 0.6 0.6;
  Cairo.stroke cr;

  Cairo.select_font_face cr "serif"
    Cairo.FONT_SLANT_NORMAL Cairo.FONT_WEIGHT_BOLD;
  Cairo.set_font_size cr 0.1;
  Cairo.move_to cr 0.1 0.1;
  Cairo.show_text cr "THIS IS SOME TEXT";
  Cairo.move_to cr 0.1 0.2;
  Cairo.show_text cr "THIS IS SOME TEXT";
  Cairo.set_font_size cr 0.05;
  Cairo.move_to cr 0.1 0.3;
  Cairo.show_text cr "THIS IS SOME TEXT";

  Cairo.set_source_rgb cr ~red:0.1 ~green:0.1 ~blue:0.1;
  Cairo.move_to cr 0.1 0.1;
  Cairo.line_to cr 0.1 0.2;
  Cairo.stroke cr;

  ()

let test_cairo () =
  let w = GWindow.window ~title:"test" () in
  ignore (w#connect#destroy GMain.quit);
  let px = GDraw.pixmap ~width ~height ~window:w () in
  px#set_foreground `WHITE;
  px#rectangle ~x:0 ~y:0 ~width ~height ~filled:true ();
  let cr = Cairo_lablgtk.create px#pixmap in
  test_draw cr;
  
  ignore(GMisc.pixmap px ~packing:w#add ());
  w#show ();
  GMain.main();
  ()
  
(*---------------------------------------------------------------------------*)
(* the command line flags *)
(*---------------------------------------------------------------------------*)
let extra_actions () = [
 <<actions>>
]
 
(*****************************************************************************)
(* The options *)
(*****************************************************************************)

(* update: try to put ocamlgtk related tests in widgets/test_widgets.ml, not
 * here. Here it's for ... well it's for nothing I think because it's not 
 * really easy to test a gui.
 *)
let all_actions () = 
 extra_actions()++
 []

let options () = [ 
  <<options>>
  ] ++
  Common.options_of_actions action (all_actions()) ++
  Common2.cmdline_flags_devel () ++
  Common2.cmdline_flags_verbose () ++
  [
  "-version",   Arg.Unit (fun () -> 
    pr2 (spf "CodeMap version: %s" Config_pfff.version);
    exit 0;
  ), 
    "  guess what";
  ]

(*****************************************************************************)
(* The main entry point *)
(*****************************************************************************)
let main () = 
  Common_extra.set_link ();

  let usage_msg = 
    spf "Usage: %s [options] <file or dir> \nDoc: %s\nOptions:"
      (Filename.basename Sys.argv.(0))
      "https://github.com/facebook/pfff/wiki/Codemap"
  in
  let args = Common.parse_options (options()) usage_msg Sys.argv in

  (* must be done after Arg.parse, because Common.profile is set by it *)
  Common.profile_code "Main total" (fun () -> 

    (match args with
    (* --------------------------------------------------------- *)
    (* actions, useful to debug subpart *)
    (* --------------------------------------------------------- *)
    | xs when List.mem !action (Common.action_list (all_actions())) -> 
        Common.do_action !action xs (all_actions())

    | _ when not (Common.null_string !action) -> 
        failwith ("unrecognized action or wrong params: " ^ !action)

    (* --------------------------------------------------------- *)
    (* main entry *)
    (* --------------------------------------------------------- *)
    | (x::xs) -> 
        main_action (x::xs)

    (* --------------------------------------------------------- *)
    (* empty entry *)
    (* --------------------------------------------------------- *)
    | _ -> Arg.usage (Arg.align (options())) usage_msg; 
    );
  )

(*****************************************************************************)
let _ = 
  Common.main_boilerplate (fun () ->
    main ()
  )
@ 

\subsection{[[flag_visual.ml]]}


\subsection{[[model_graph_code.mli]]}

<<model_graph_code.mli>>=
val build_uses_and_users_of_file: 
  Graph_code.graph ->
  (Common.filename, Common.filename list) Common.assoc * (* uses_of_file *)
  (Common.filename, Common.filename list) Common.assoc   (* husers_of_file *) 

(* the nodes are sorted by line numbers *)
val build_entities_of_file:
  Graph_code.graph ->
  (Common.filename, (int * Graph_code.node) list) Common.assoc
@ 

\subsection{[[model_database_code.mli]]}

<<model_database_code.mli>>=

<<hentities sig>>

<<hfiles_and_top_entities sig>>

<<all_entities sig>>

<<actual_root_of_db sig>>

<<readable_to_absolute_filename_under_root sig>>

@ 

\subsection{[[model_graph_code.ml]]}

<<model_graph_code.ml>>=
<<Facebook copyright>>
open Common

module G = Graph_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

let build_uses_and_users_of_file g =

  (* we use the 'find_all' property of those hashes *)
  let huses = Hashtbl.create 101 in
  let husers = Hashtbl.create 101 in

  let halready = Hashtbl.create 101 in

  g +> G.iter_use_edges (fun n1 n2 ->
    try 
      let file1 = G.file_of_node n1 g in
      let file2 = G.file_of_node n2 g in
      if file1 <> file2 && not (Hashtbl.mem halready (file1, file2)) then begin
        Hashtbl.replace halready (file1, file2) true;
        Hashtbl.add huses file1 file2;
        Hashtbl.add husers file2 file1;
      end;
    with Not_found -> ()
  );

  Common2.hkeys huses +> List.map (fun k -> k, Hashtbl.find_all huses k),
  Common2.hkeys husers +> List.map (fun k -> k, Hashtbl.find_all husers k)

let build_entities_of_file g =

  (* we use the 'find_all' property of those hashes *)
  let h = Hashtbl.create 101 in

  g +> G.iter_nodes (fun n ->
    try 
      let info = G.nodeinfo n g in
      let file = info.G.pos.Parse_info.file in
      (* codemap use line numbers starting at 0 *)
      let line = info.G.pos.Parse_info.line - 1 in

      Hashtbl.add h file (line, n);
    with Not_found -> ()
  );
  Common2.hkeys h +> List.map (fun k ->
    let xs = Hashtbl.find_all h k in
    k, Common.sort_by_key_lowfirst xs
  )

@ 

\subsection{[[model_database_code.ml]]}

<<model_database_code.ml>>=
<<Facebook copyright>>
open Common

module Flag = Flag_visual
module Db = Database_code

(*****************************************************************************)
(* Filenames *)
(*****************************************************************************)

<<readable_to_absolute_filename_under_root>>

<<actual_root_of_db>>

(*****************************************************************************)
(* Entities info *)
(*****************************************************************************)

<<hentities()>>

<<hfiles_and_top_entities()>>

(*****************************************************************************)
(* Completion data *)
(*****************************************************************************)

<<all_entities>>


@ 


\subsection{[[model2.mli]]}

<<model2.mli>>=

<<type model>>

type macrolevel = Treemap.treemap_rendering

type microlevel = {
  pos_to_line: Cairo.point -> int;
  line_to_rectangle: int -> Figures.rectangle;
  layout: layout;
  container: Treemap.treemap_rectangle;
  content: (glyph list) array option;
}
  and glyph = {
    str: string;
    categ: Highlight_code.category option;
    font_size: float;
    color: Simple_color.emacs_color;
  }
  and layout = {
    lfont_size: float;
    split_nb_columns: float; (* int *)
    width_per_column:float;
    height_per_line: float;
    nblines: float; (* int *)
    nblines_per_column: float; (* int *)
  }

<<type drawing>>

<<type context>>
val context_of_drawing: drawing -> context


<<init_drawing sig>>

<<new_pixmap sig>>

(* point -> rectangle -> line -> entity *)

<<find_rectangle_at_user_point sig>>

val find_line_in_rectangle_at_user_point:
  drawing ->
  Cairo.point -> 
  Treemap.treemap_rectangle ->
  int option

val find_entity_at_line:
  int (* line *) -> Treemap.treemap_rectangle -> drawing -> 
  Graph_code.node option


(* graph code integration *)

(* macrolevel uses and users *)
val uses_and_users_readable_files_of_file:
  Common.filename (* absolute *) -> drawing -> 
  Common.filename list (* readable *) * Common.filename list (* readable *)

val uses_and_users_rect_of_file:
  Common.filename -> drawing -> 
  Treemap.treemap_rectangle list * Treemap.treemap_rectangle list

(* microlevel uses and users *)
val uses_and_users_readable_files_of_node:
  Graph_code.node -> drawing -> 
  Common.filename list (* readable *) * Common.filename list (* readable *)

val uses_and_users_of_node:
  Graph_code.node -> drawing -> 
  (Graph_code.node * int * microlevel) list * 
  (Graph_code.node * int * microlevel) list

val lines_where_used_node:
  Graph_code.node -> int -> microlevel -> int list

@ 

\subsection{[[model2.ml]]}


<<model2.ml>>=
<<Facebook copyright>>
open Common

module CairoH = Cairo_helpers

module F = Figures
module T = Treemap

module Flag = Flag_visual

(*****************************************************************************)
(* The code model *)
(*****************************************************************************)

<<type model>>


(*****************************************************************************)
(* The drawing model *)
(*****************************************************************************)

type macrolevel = Treemap.treemap_rendering

type microlevel = {
  pos_to_line: Cairo.point -> int;
  line_to_rectangle: int -> Figures.rectangle;
  layout: layout;
  container: Treemap.treemap_rectangle;
  content: (glyph list) array option;
}
  and glyph = {
    str: string;
    categ: Highlight_code.category option;
    font_size: float;
    color: Simple_color.emacs_color;
  }
  and layout = {
    lfont_size: float;
    split_nb_columns: float; (* int *)
    width_per_column:float;
    height_per_line: float;
    nblines: float; (* int *)
    nblines_per_column: float; (* int *)
  }


<<type drawing>>

<<new_pixmap()>>

<<init_drawing()>>

(*****************************************************************************)
(* The drawing context *)
(*****************************************************************************)

<<type context>>

let context_of_drawing dw = { 
  nb_rects_on_screen = dw.nb_rects;
  model = dw.dw_model;
  settings = dw.dw_settings;
  grep_query = dw.current_grep_query;
  layers_microlevel = dw.layers.Layer_code.micro_index;
}

(*****************************************************************************)
(* Point -> (rectangle, line, entity) *)
(*****************************************************************************)

<<find_rectangle_at_user_point()>>


let find_line_in_rectangle_at_user_point dw user_pt r =
  try 
    let microlevel = Hashtbl.find dw.microlevel r in
    let line = microlevel.pos_to_line user_pt in
    Some line
  with Not_found -> None

(*****************************************************************************)
(* Graph code integration *)
(*****************************************************************************)

let find_entity_at_line line r dw =
  let model = Async.async_get dw.dw_model in
  let file = r.T.tr_label in
  let readable = Common.filename_without_leading_path model.root file in
  try 
    let xs = Hashtbl.find model.hentities_of_file readable in
    xs +> List.rev +> Common.find_some_opt (fun (line2, n) ->
      if line = line2 (* && abs (line - line2) <= 4 *)
      then Some n 
      else None
    )
  with Not_found -> None


let uses_and_users_readable_files_of_file file dw =
  let model = Async.async_get dw.dw_model in
  let readable = Common.filename_without_leading_path model.root file in

  let uses = 
    try Hashtbl.find model.huses_of_file readable with Not_found -> [] in
  let users = 
    try Hashtbl.find model.husers_of_file readable with Not_found -> [] in
  uses, users

let uses_and_users_readable_files_of_node node dw =
  let model = Async.async_get dw.dw_model in
  match model.g with
  | None -> [], []
  | Some g ->
    let succ = Graph_code.succ node Graph_code.Use g in
    let pred = Graph_code.pred node Graph_code.Use g in
    succ +> Common.map_filter (fun n ->
      try Some (Graph_code.file_of_node n g) with Not_found -> None
    ),
    pred +> Common.map_filter (fun n ->
      try Some (Graph_code.file_of_node n g) with Not_found -> None
    )

let uses_and_users_rect_of_file file dw =
  let uses, users = uses_and_users_readable_files_of_file file dw in
  uses +> Common.map_filter (fun file -> 
    Common2.optionise (fun () -> Hashtbl.find dw.readable_file_to_rect file)
  ),
  users +> Common.map_filter (fun file ->
    Common2.optionise (fun () ->Hashtbl.find dw.readable_file_to_rect file)
  )


let uses_or_users_of_node node dw fsucc =
  let model = Async.async_get dw.dw_model in
  match model.g with
  | None -> []
  | Some g ->
    let succ = fsucc node g in
    succ +> Common.map_filter (fun n ->
      try 
        let file = Graph_code.file_of_node n g in
        let rect = Hashtbl.find dw.readable_file_to_rect file in
        let xs = Hashtbl.find model.hentities_of_file file in
        let (line, _n2) = xs +> List.find (fun (_, n2) -> n2 =*= n) in
        let microlevel = Hashtbl.find dw.microlevel rect in
        Some (n, line, microlevel)
      with Not_found -> None
    )

let uses_and_users_of_node node dw =
  uses_or_users_of_node node dw (fun node g ->
    Graph_code.succ node Graph_code.Use g),
  uses_or_users_of_node node dw (fun node g ->
    Graph_code.pred node Graph_code.Use g)


let lines_where_used_node node startl microlevel =
  let (fullstr, kind) = node in
  let xs = Common.split "\\." fullstr in
  let s = Common2.list_last xs in
  
  match microlevel.content with
  | None -> []
  | Some glypys ->
    
    let res = ref [] in
    for line = startl to Array.length glypys - 1 do
      let xs = glypys.(line) in
      if xs +> List.exists (fun glyph ->
        let categ =
          match glyph.categ with
          | Some x -> x
          | _ -> Highlight_code.Normal
        in
        glyph.str =$= s &&
          
        (* see the code of the different highlight_code_xxx.ml to
         * know the different possible pairs
         *)
        (match kind, categ with
        | Database_code.Function, Highlight_code.Function _
        | Database_code.Field, Highlight_code.Field _
        | Database_code.Constructor, Highlight_code.ConstructorUse _
        | Database_code.Global, Highlight_code.Global _

        (* tofix at some point, wrong tokenizer *)
        | Database_code.Constant, Highlight_code.Local _
        | Database_code.Global, Highlight_code.Local _
        | Database_code.Function, Highlight_code.Local _

        | Database_code.Global, Highlight_code.UseOfRef
         -> true

        | _ -> false
        )
      )
      then Common.push2 line res
    done;
    !res

@ 

\subsection{[[view2.mli]]}


<<view2.mli>>=
<<mk_gui sig>>
@ 


\subsection{[[view2.ml]]}




<<view2.ml>>=
<<Facebook copyright>>
open Common2
open Common
(* floats are the norm in graphics *)
open Common2.ArithFloatInfix

module G = Gui
module K = GdkKeysyms
module GR = Gdk.Rectangle

open Figures (* for the fields *)
module F = Figures
module T = Treemap

module CairoH = Cairo_helpers

open Model2 (* for the fields *)
module M = Model2
module Controller = Controller2

module Flag = Flag_visual
module Style = Style2

module Db = Database_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Wrappers *)
(*****************************************************************************)
let pr2, pr2_once = Common2.mk_pr2_wrappers Flag.verbose_visual

(*****************************************************************************)
(* Globals *)
(*****************************************************************************)

<<view globals>>

(*****************************************************************************)
(* Final view rendering *)
(*****************************************************************************)

(* ---------------------------------------------------------------------- *)
(* The main-map *)
(* ---------------------------------------------------------------------- *)

<<assemble_layers>>

<<expose>>

<<configure>>

(* ---------------------------------------------------------------------- *)
(* The legend *)
(* ---------------------------------------------------------------------- *)
<<expose_legend>>

(*****************************************************************************)
(* Events *)
(*****************************************************************************)

(*****************************************************************************)
(* The main UI *)
(*****************************************************************************)

<<mk_gui()>>

@ 


\subsection{[[controller2.mli]]}

<<controller2.mli>>=

val _refresh_da: (unit -> unit) ref
val _refresh_legend: (unit -> unit) ref

val _go_back: 
  (Model2.drawing ref -> unit) ref
val _go_dirs_or_file: 
  (?current_entity: Database_code.entity option ->
   ?current_grep_query: (string, int) Hashtbl.t option ->
    Model2.drawing ref -> Common.path list -> unit
  ) ref

val _statusbar_addtext: (string -> unit) ref
val _set_title: (string -> unit) ref

val current_rects_to_draw:
  (Treemap.treemap_rectangle list) ref
val current_r:
  Treemap.treemap_rectangle option ref

val paint_content_maybe_refresher:
  GMain.Idle.id option ref
val current_motion_refresher:
  GMain.Idle.id option ref

val dw_stack:
  Model2.drawing list ref

val title_of_path: string -> string

@ 


\subsection{[[controller2.ml]]}

<<controller2.ml>>=
<<Facebook copyright>>

let _refresh_da = ref (fun () ->
  failwith "_refresh_da not defined"
)
let _refresh_legend = ref (fun () ->
  failwith "_refresh_legend not defined"
)

let current_rects_to_draw = ref []

let current_r = ref None

let paint_content_maybe_refresher = ref None

let current_motion_refresher = ref None

let dw_stack = ref []



let _go_back = ref (fun dw_ref ->
  failwith "_go_back not defined"
)

let _go_dirs_or_file = ref 
 (fun ?(current_entity=None) ?(current_grep_query=None)  dw_ref paths ->
  failwith "_go_dirs_or_file not defined"
)

let _statusbar_addtext = ref (fun s ->
  failwith "_statusbar_addtext not defined"
)
let _set_title = ref (fun s ->
  failwith "_set_title not defined"
)

let title_of_path s = "CodeMap: " ^ s

@ 

\subsection{[[help.mli]]}

<<help.mli>>=
val interface_doc: string

@ 

\subsection{[[help.ml]]}

<<help.ml>>=
<<interface_doc>>
@ 
 


\subsection{[[draw_common.mli]]}

<<draw_common.mli>>=

(* current used also by draw_macrolevel *)
val final_font_size_when_multiplier:
  multiplier:float ->
  size_font_multiplier_multiplier:float ->
  font_size:float -> font_size_real:'a -> float

@ 

\subsection{[[draw_common.ml]]}

<<draw_common.ml>>=
<<Facebook copyright>>
open Common
open Common2.ArithFloatInfix
module CairoH = Cairo_helpers

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Anamorphic entities *)
(*****************************************************************************)

<<final_font_size_when_multiplier>>


@ 

 


\subsection{[[draw_macrolevel.mli]]}

<<draw_macrolevel.mli>>=

<<draw_treemap_rectangle sig>>

val draw_trect_using_layers:
  cr:Cairo.t ->
  Layer_code.layers_with_index ->
  Treemap.treemap_rectangle -> 
  unit

@ 

\subsection{[[draw_macrolevel.ml]]}

<<draw_macrolevel.ml>>=
<<Facebook copyright>>
open Common
open Common2.ArithFloatInfix

open Figures (* for the fields *)
open Model2 (* for the fields *)

module T = Treemap
module F = Figures
module Color = Simple_color

module Db = Database_code
module HC = Highlight_code

module CairoH = Cairo_helpers
module  Parsing = Parsing2

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Drawing a treemap rectangle *)
(*****************************************************************************)

<<draw_treemap_rectangle()>>


(*****************************************************************************)
(* Layers macrolevel *)
(*****************************************************************************)

(* How should we draw layer information at the macro level ?
 *   
 *  - fill the rectangle with the color of one layer ? 
 *  - separate equally among layers ? 
 *  - draw on top of the existing archi color ?
 *  - draw circles instead of rectangle so have quantitative information too 
 *    (like I was doing when display git related commit information).
 * 
 * It is maybe good to not draw on top of the existing archi_code color. 
 * Too many colors kill colors. Also we can not convey quantitative 
 * information by coloring with full rectangles (instead of the random
 * circles trick) but for some layers like security it is probably better.
 * Don't care so much about how many bad calls; care really about
 * number of files with bad calls in them.
 * 
 * So for now we just fill rectangles with colors from the layer and
 * when a file matches multiple layers we split the rectangle in equal
 * parts.
 *)

let draw_trect_using_layers ~cr layers_with_index rect =
  let _r = rect.T.tr_rect in

  (* don't use archi_code color. Just black and white *)
  let is_file = not rect.T.tr_is_node in
  let color = if is_file then "white" else "black" in
  draw_treemap_rectangle ~cr ~color:(Some color) rect;

  if is_file then begin
    let file = rect.T.tr_label in
    
    let color_info = 
      try Hashtbl.find layers_with_index.Layer_code.macro_index file
      with Not_found -> []
    in
    (* What to draw ? 
     * TODO a splitted rectangle ? 
     * For now the last win ...
     * todo? could use the quantitative information in the float ?
     *)
    color_info +> List.iter (fun (float, color) -> 
      draw_treemap_rectangle ~cr ~color:(Some color) rect;
    );
  end

(*****************************************************************************)
(* File Summary *)
(*****************************************************************************)

<<draw_summary_content>>
@ 

\subsection{[[draw_microlevel.mli]]}

<<draw_microlevel.mli>>=

<<draw_treemap_rectangle_content_maybe sig>>

<<text_with_user_pos sig>>

val draw_magnify_line:
  Cairo.t -> int -> Model2.microlevel -> unit
@ 

\subsection{[[draw_microlevel.ml]]}

<<draw_microlevel.ml>>=
<<Facebook copyright>>
open Common
open Common2.ArithFloatInfix

open Figures (* for the fields *)
module F = Figures
module T = Treemap
module Color = Simple_color
module CairoH = Cairo_helpers

open Model2 (* for the fields *)
module M = Model2

module Flag = Flag_visual
module Style = Style2

module FT = File_type
module Parsing = Parsing2

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* There are many different coordinates relevant to the lines of a file:
 *  - line number in the file
 *  - column and line in column for the file when rendered in multiple columns
 *  - x,y position relative to the current treemap rectangle
 *  - x,y position on the screen
 * We have many functions below to go from one to the other.
 * 
 * note: some types below could be 'int' but it's more convenient to have
 * everything as a float because arithmetic with OCaml sucks when have
 * multiple numeric types.
 * 
 * Below line numbers starts at 0, not at 1 as in emacs.
 *)

type line = int

type line_in_column = {
  column: float; (* int *)
  line_in_column: float; (* int *)
}

type pos = float (* x *) * float (* y *)

type point = Cairo.point

<<type draw_content_layout>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let is_big_file_with_few_lines ~nblines file = 
  nblines < 20. && Common2.filesize_eff file > 4000

(* coupling: with parsing2.ml *)
let use_fancy_highlighting file =
  match FT.file_type_of_file file with
  | ( FT.PL (FT.Web (FT.Php _))
    | FT.PL (FT.Web (FT.Js))
    | FT.PL (FT.Web (FT.Html))
    | FT.PL (FT.ML _)
    | FT.PL (FT.Cplusplus _ | FT.C _)
    | FT.PL (FT.Thrift)
    | FT.Text ("nw" | "tex"  | "texi" | "web" | "org")
    | FT.PL (FT.Lisp _)
    | FT.PL (FT.Haskell _)
    | FT.PL (FT.Python)
    | FT.PL (FT.Csharp)
    | FT.PL (FT.Java)
    (*    | FT.PL (FT.Prolog _) *)
    | FT.PL (FT.Erlang)
    | FT.PL (FT.Opa)
    ) -> true
  | (FT.Text "txt") when Common2.basename file =$= "info.txt" -> true
  | _ -> false

(*****************************************************************************)
(* Coordinate conversion *)
(*****************************************************************************)

let line_in_column_to_bottom_pos lc r layout =
  let x = r.p.x + (lc.column * layout.width_per_column) in
  (* to draw text in cairo we need to be one line below, hence the +1
   * as y goes down but the text is drawn above
   *)
  let y = r.p.y + ((lc.line_in_column + 1.) * layout.height_per_line) in
  x, y

let line_to_line_in_column line layout =
  let line = float_of_int line in
  let column = floor (line / layout.nblines_per_column) in
  let line_in_column = 
    line - (column * layout.nblines_per_column) in
  { column; line_in_column }

let line_to_rectangle line r layout =
  let lc = line_to_line_in_column line layout in
  (* this is the bottom pos, so we need to substract height_per_line
   * if we want to draw above the bottom pos
   *)
  let x, y = line_in_column_to_bottom_pos lc r layout in
  { p = { x; 
          y = y - layout.height_per_line };
    q = { x = x + layout.width_per_column; 
          y = y + 0.2 * layout.height_per_line };
  }

let point_to_line pt r layout =
  let x = pt.Cairo.x - r.p.x in
  let y = pt.Cairo.y - r.p.y in
  let line_in_column = floor (y / layout.height_per_line) in
  let column = floor (x / layout.width_per_column) in
  (column * layout.nblines_per_column + line_in_column) +> int_of_float

(*****************************************************************************)
(* Content properties *)
(*****************************************************************************)

(* Anamorphic entities *)
<<final_font_size_of_categ>>

let color_of_categ categ =
  let attrs =
    match categ with
    | None ->       Highlight_code.info_of_category Highlight_code.Normal
    | Some categ -> Highlight_code.info_of_category categ
  in
  attrs +> Common.find_some (fun attr ->
    match attr with
    | `FOREGROUND s 
    | `BACKGROUND s (* todo: should really draw the background of the text *)
      -> 
        Some (s)
    | _ -> None
  )

let glyphs_of_file ~context ~font_size ~font_size_real file 
  : (glyph list) array option =

  match FT.file_type_of_file file with
  | _ when use_fancy_highlighting file ->

    let model = Async.async_get context.model in
    let entities = model.Model2.hentities in

    (* can't use nblines_eff here, we don't want to memoize *)
    let nblines = Common2.nblines_eff file in
    let arr = Array.create nblines [] in

    let tokens_with_categ = Parsing.tokens_with_categ_of_file file entities in

    let line = ref 0 in
    let acc = ref [] in
    (try (
     tokens_with_categ +> List.iter (fun (s, categ, _filepos) ->
      let final_font_size = 
        final_font_size_of_categ ~font_size ~font_size_real categ in
      let color = 
        color_of_categ categ in

      let xs = Common2.lines_with_nl_either s in
      xs +> List.iter (function
      | Common2.Left str ->
        Common.push2 { M. str; font_size = final_font_size; color; categ } acc;
      | Common2.Right () ->
        arr.(!line) <- List.rev !acc;
        acc := [];
        incr line;
      )
    );
    if !acc <> []
    then arr.(!line) <- List.rev !acc;
    Some arr
    ) with Invalid_argument("index out of bounds") ->
      failwith (spf "try on %s, nblines = %d, line = %d" file nblines !line)
    )

  | FT.PL _ | FT.Text _ ->      
    (Common.cat file)
    +> List.map (fun str -> [{ M.str; font_size; color = "black"; categ=None }])
    +> Array.of_list
    +> (fun x -> Some x)
  | _ -> None

(*****************************************************************************)
(* Columns *)
(*****************************************************************************)

<<font_size_when_have_x_columns>>
   
<<optimal_nb_columns>>

<<draw_column_bars>>


(*****************************************************************************)
(* File Content *)
(*****************************************************************************)

<<draw_content>>


<<draw_treemap_rectangle_content_maybe>>
    
(*****************************************************************************)
(* Magnifyer Content *)
(*****************************************************************************)

(* alt: digital zoom? good enough? need rendering at better resolution? *)
let draw_magnify_line cr line microlevel =
  match microlevel.content with
  | None -> ()
  | Some glyphs ->
    let r = microlevel.container.T.tr_rect in
    let layout = microlevel.layout in

    let lc = line_to_line_in_column line layout in
    let x, y = line_in_column_to_bottom_pos lc r layout in
    Cairo.move_to cr x y;
    
    glyphs.(line) +> List.iter (fun glyph ->
      let font_size = glyph.M.font_size * 3. in
      Cairo.set_font_size cr font_size;
      let (r,g,b) = Color.rgbf_of_string glyph.color in
      let alpha = 1. in
      Cairo.set_source_rgba cr r g b alpha;
      CairoH.show_text cr glyph.M.str;
    )

@ 

\subsection{[[draw_labels.mli]]}

<<draw_labels.mli>>=

<<draw_treemap_rectangle_label_maybe sig>>

@ 

\subsection{[[draw_label.ml]]}

<<draw_labels.ml>>=
<<Facebook copyright>>
open Common
open Common2.ArithFloatInfix

open Figures (* for the fields *)
open Model2 (* for the fields *)

module Flag = Flag_visual

module T = Treemap
module F = Figures
module Color = Simple_color

module CairoH = Cairo_helpers

(*****************************************************************************)
(* Label *)
(*****************************************************************************)

<<draw_treemap_rectangle_label_maybe>>

@ 

\subsection{[[draw_legend.mli]]}

<<draw_legend.mli>>=
val draw_legend: cr:Cairo.t -> unit

val draw_legend_layer: cr:Cairo.t -> Layer_code.layers_with_index -> unit

@

\subsection{[[draw_legend.ml]]}

<<draw_legend.ml>>=
<<Facebook copyright>>
open Common
open Common2.ArithFloatInfix

module CairoH = Cairo_helpers

module L = Layer_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let draw_legend_of_color_string_pairs ~cr xs = 

  Cairo.select_font_face cr "serif" 
    Cairo.FONT_SLANT_NORMAL Cairo.FONT_WEIGHT_NORMAL;
  let size = 25.  in

  Cairo.set_font_size cr (size * 0.6);

  Cairo.set_source_rgba cr 0. 0. 0.    1.0;
  
  xs +> Common.index_list_1 +> List.iter (fun ((color,s), i) ->
    
    let x = 10. in
    let y = float_of_int i * size in

    let w = size in
    let h = size in

    CairoH.fill_rectangle ~cr ~color ~x ~y ~w ~h ();
    Cairo.set_source_rgba cr 0. 0. 0.    1.0;
    Cairo.move_to cr (x + size * 2.) (y + size * 0.8);
    Cairo.show_text cr s;
  );
  ()
  
(*****************************************************************************)
(* Drawing *)
(*****************************************************************************)

<<paint_legend>>

let draw_legend_layer ~cr layers_idx = 
  let pairs = 
    layers_idx.L.layers +> Common.map_filter (fun (layer, is_active) ->
      if is_active
      then Some layer.L.kinds
      else None
    ) +> List.flatten +> List.map (fun (a, b) -> (b, a))
  in
  draw_legend_of_color_string_pairs ~cr pairs

@


\subsection{[[view_mainmap.mli]]}

<<view_mainmap.mli>>=

val paint: Model2.drawing -> unit

val zoom_pan_scale_map: Cairo.t -> Model2.drawing -> unit

val device_to_user_area: Model2.drawing -> Figures.rectangle

val with_map: Model2.drawing -> (Cairo.t -> 'a) -> 'a

val button_action:
 < as_widget : [> `widget ] Gtk.obj; .. > ->
   Model2.drawing ref -> GdkEvent.Button.t -> bool

@ 

\subsection{[[view_mainmap.ml]]}

<<view_mainmap.ml>>=
<<Facebook copyright>>

open Common
(* floats are the norm in graphics *)
open Common2.ArithFloatInfix

module CairoH = Cairo_helpers
module K = GdkKeysyms

module F = Figures
module T = Treemap

module Flag = Flag_visual
open Model2
module M = Model2
module Ctl = Controller2

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * This module calls Draw_macrolevel and Draw_microlevel and assembles
 * the final "painting" of the code "main map". It is called mainly by
 * View2.configure and Ui_navigation.go_dirs_and_file.
 * 
 * Painting is not the last element in the "main map" rendering pipeline.
 * There is also View_overlay which is called mainly when the user
 * moves the mouse which triggers the View_overlay.motion_refresher
 * callback which just add overlays on top of the already drawn (and
 * computationaly expensive) painting done here. 
 *)

(*****************************************************************************)
(* Types, globals *)
(*****************************************************************************)


(*****************************************************************************)
(* Scaling *)
(*****************************************************************************)

<<zoom_pan_scale_map>>

<<with_map>>

<<device_to_user_area>>


(*****************************************************************************)
(* Painting *)
(*****************************************************************************)

<<paint>>

(*****************************************************************************)
(* Events *)
(*****************************************************************************)

<<key_pressed>>

<<find_filepos_in_rectangle_at_user_point>>
            

<<button_action>>


@ 

\subsection{[[view_minimap.mli]]}

<<view_minimap.mli>>=
@ 

\subsection{[[view_minimap.ml]]}

<<view_minimap.ml>>=
<<Facebook copyright>>

open Common
(* floats are the norm in graphics *)
open Common2.ArithFloatInfix

module GR = Gdk.Rectangle

module F = Figures
module T = Treemap
module CairoH = Cairo_helpers

module Flag = Flag_visual
open Model2
module Controller = Controller2

(*****************************************************************************)
(* Scaling *)
(*****************************************************************************)

<<scale_minimap>>

<<with_minimap>>

(*****************************************************************************)
(* Painting *)
(*****************************************************************************)

<<paint_minimap>>

(* ---------------------------------------------------------------------- *)
(* The mini-map *)
(* ---------------------------------------------------------------------- *)

<<expose_minimap>>

<<configure_minimap>>

(* ---------------------------------------------------------------------- *)
(* The mini-map *)
(* ---------------------------------------------------------------------- *)

<<motion_notify_minimap>>

<<button_action_minimap>>



@ 


\subsection{[[view_overlays.mli]]}

<<view_overlays.mli>>=

val draw_searched_rectangles:
  dw:Model2.drawing -> unit

val motion_notify:
  < as_widget : [> `widget ] Gtk.obj; .. > *
  < as_widget : [> `widget ] Gtk.obj; .. > ->
  Model2.drawing ref -> GdkEvent.Motion.t -> bool

@ 


\subsection{[[view_overlays.ml]]}

<<view_overlays.ml>>=
<<Facebook copyright>>
open Common
(* floats are the norm in graphics *)
open Common2.ArithFloatInfix

module F = Figures
module T = Treemap
module CairoH = Cairo_helpers

module Flag = Flag_visual
open Model2
module Controller = Controller2
module Style = Style2

open Figures (* for the fields *)
module M = Model2

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* This module mainly modifies the dw.overlay cairo surface. It also
 * triggers the refresh_da which triggers itself the expose event
 * which triggers the View2.assemble_layers composition of dw.pm with
 * dw.overlay.
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let readable_txt_for_label txt current_root =
  let readable_txt = 
    if current_root =$= txt (* when we are fully zoomed on one file *)
    then "root"
    else Common.filename_without_leading_path current_root txt 
  in
  if String.length readable_txt > 25
  then 
    let dirs = Filename.dirname readable_txt +> Common.split "/" in
    let file = Filename.basename readable_txt in
    spf "%s/.../%s" (List.hd dirs) file
  else readable_txt

let with_overlay dw f =
  let cr_overlay = Cairo.create dw.overlay in
  View_mainmap.zoom_pan_scale_map cr_overlay dw;
  f cr_overlay

(*****************************************************************************)
(* The overlays *)
(*****************************************************************************)

(* ---------------------------------------------------------------------- *)
(* The current filename *)
(* ---------------------------------------------------------------------- *)
<<draw_label_overlay>>

(* ---------------------------------------------------------------------- *)
(* The current rectangles *)
(* ---------------------------------------------------------------------- *)

<<draw_rectangle_overlay>>

(* ---------------------------------------------------------------------- *)
(* Uses and users macrolevel *)
(* ---------------------------------------------------------------------- *)
let draw_uses_users_files ~dw r =
 with_overlay dw (fun cr_overlay ->
   let file = r.T.tr_label in
   let uses_rect, users_rect = M.uses_and_users_rect_of_file file dw in
   uses_rect +> List.iter (fun r ->
     CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"green" r.T.tr_rect;
   );
   users_rect +> List.iter (fun r ->
     CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"red" r.T.tr_rect;
   )
 )

(* ---------------------------------------------------------------------- *)
(* Uses and users microlevel *)
(* ---------------------------------------------------------------------- *)
let draw_magnify_line_overlay_maybe dw line microlevel =
  with_overlay dw (fun cr_overlay ->
    let font_size = microlevel.layout.lfont_size in
    let font_size_real = CairoH.user_to_device_font_size cr_overlay font_size in

    (* todo: put in style *)
    if font_size_real < 5.
    then Draw_microlevel.draw_magnify_line cr_overlay line microlevel
  )

let draw_uses_users_entities ~dw n =
 with_overlay dw (fun cr_overlay ->
   let uses, users = uses_and_users_of_node n dw  in
   uses +> List.iter (fun (_n2, line, microlevel) ->
     let rectangle = microlevel.line_to_rectangle line in
     CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"green" rectangle;
   );
   users +> List.iter (fun (_n2, line, microlevel) ->
     let rectangle = microlevel.line_to_rectangle line in
     CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"red" rectangle;
     
     let lines_used = M.lines_where_used_node n line microlevel in
     lines_used +> List.iter (fun line ->
       let rectangle = microlevel.line_to_rectangle line in
       CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"purple" rectangle;

       draw_magnify_line_overlay_maybe dw line microlevel;
     );
   );
 )

(* ---------------------------------------------------------------------- *)
(* The selected rectangles *)
(* ---------------------------------------------------------------------- *)

<<draw_searched_rectangles>>

(* ---------------------------------------------------------------------- *)
(* The magnifying glass *)
(* ---------------------------------------------------------------------- *)

<<zoomed_surface_of_rectangle>>

(*****************************************************************************)
(* Assembling overlays *)
(*****************************************************************************)

<<motion_refresher>>

<<idle>>


@ 

\subsection{[[ui_search.mli]]}

<<ui_search.mli>>=

val dialog_search_def: 
  Model2.model Async.t -> string option

val run_grep_query:
  root:string -> string -> (string * int) list

val run_tbgs_query:
  root:string -> string -> (string * int) list

@ 


\subsection{[[ui_search.ml]]}

<<ui_search.ml>>=
<<Facebook copyright>>
open Common
(* floats are the norm in graphics *)
open Common2.ArithFloatInfix

module G = Gui

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(* ---------------------------------------------------------------------- *)
(* Search *)
(* ---------------------------------------------------------------------- *)

<<dialog_search_def>>

<<run_grep_query>>

<<run_tbgs_query>>

@ 

\subsection{[[ui_navigation.mli]]}

<<ui_navigation.mli>>=

val go_back: 
  Model2.drawing ref -> unit

val go_dirs_or_file:
  ?current_entity:Database_code.entity option ->
  ?current_grep_query:(Common.filename, int) Hashtbl.t option ->
  Model2.drawing ref -> Common.filename list -> unit

@ 


\subsection{[[ui_navigation.ml]]}

<<ui_navigation.ml>>=
<<Facebook copyright>>
open Common
(* floats are the norm in graphics *)
open Common2.ArithFloatInfix

module G = Gui

open Model2
module Controller = Controller2

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(* ---------------------------------------------------------------------- *)
(* Navigation *)
(* ---------------------------------------------------------------------- *)

<<go_back>>

<<go_dirs_or_file>>

@ 




\subsection{[[parsing2.mli]]}

\subsection{[[parsing2.ml]]}

\subsection{[[completion2.mli]]}

\subsection{[[completion2.ml]]}

\subsection{[[style2.mli]]}

\subsection{[[style2.ml]]}

<<style2.ml>>=
<<Facebook copyright>>
open Common

module SH = Highlight_code
module Flag = Flag_visual

(*****************************************************************************)
(* Visual style *)
(*****************************************************************************)
(* see also model2.settings *)

<<zoom_factor_incruste_mode>>

<<threshold_draw_dark_background_font_size_real>>

let font_size_filename_cursor = 30.

(* see also Cairo_helpers.prepare_string which may double the spaces *)
let font_text = 
  match 0 with
  | 0 -> "serif"

  | 1 -> "helvetica"
  | 2 -> "courier"
  | 3 -> "arial"
  | 4 -> "consolas"
  | 5 -> "dejavu"
  | 6 -> "terminal"
  | _ -> raise Impossible

<<size_font_multiplier_of_categ()>>

<<windows_params()>>

@ 

\subsection{[[editor_connection.mli]]}


\subsection{[[editor_connection.ml]]}

<<editor_connection.ml>>=
<<Facebook copyright>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Emacs *)
(*****************************************************************************)

<<emacs configuration>>

(*****************************************************************************)
(* Vi *)
(*****************************************************************************)

(*****************************************************************************)
(* Wrappers *)
(*****************************************************************************)

<<open_file_in_current_editor()>>
@ 


\subsection{[[async.mli]]}

<<async.mli>>=

<<type async>>
<<async functions sig>>

@ 

\subsection{[[async.ml]]}

<<async.ml>>=
<<Facebook copyright>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Type *)
(*****************************************************************************)

<<type async>>

(*****************************************************************************)
(* Functions *)
(*****************************************************************************)

<<async functions>>

@ 

\subsection{[[cairo_helpers.mli]]}


<<cairo_helpers.mli>>=

<<cairo helpers functions sig>>
@ 

\subsection{[[cairo_helpers.ml]]}

<<cairo_helpers.ml>>=
<<Facebook copyright>>
open Common
(* floats are the norm in graphics *)
open Common2.ArithFloatInfix

open Figures
module F = Figures
module Color = Simple_color

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
let (==~) = Common2.(==~)

(*****************************************************************************)
(* Text related *)
(*****************************************************************************)

(* May have to move this in commons/ at some point *)

let re_space = Str.regexp "^[ ]+$"

<<cairo helpers functions>>

(*****************************************************************************)
(* Misc *)
(*****************************************************************************)

let is_old_cairo () = 
  let s = Cairo.compile_time_version_string in
  match () with
  | _ when s =~ "1\\.[89]\\.*" -> false
  | _ -> true


@ 

\section{Changelog}
\label{sec:changelog}

\section*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}


\bibitem[4]{common-pad-manual} Yoann Padioleau,
{\em Commons Pad OCaml Library}, 
\url{http://padator.org/docs/Commons.pdf}


\bibitem[5]{treemap-wikipedia} Wikipedia,
{\em Treemapping}, 
\url{http://en.wikipedia.org/wiki/Treemapping}


% SeeSoft and other code visualization 

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}




