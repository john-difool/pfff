package org.apache.harmony.security.tests.support;
class tmpCallbackHandler {
}
class TestUtils {
}
class TestKeyStoreSpi {
  int DUMMY;
  int KEY;
  int CERTCHAIN;
  int CERT;
  int aliases;
}
class TestKeyPair {
  int kf;
  int algorithmName;
  int publicKeyEncoding;
  int privateKeyEncoding;
}
class TestCertUtils {
  class UniGen {
    int datas;
    int datasNames;
    int rootName;
  }
  class TestFactorySpi {
  }
  class TestProvider {
    int serv;
  }
  class TestX509Certificate {
    int issuer;
    int subject;
  }
  class TestInvalidX509Certificate {
  }
  class TestCertificate {
    int diff;
    int TYPE;
    int encoded;
  }
  class TestPublicKey {
    int format;
    int encoded;
    int algo;
  }
  class TestCertPath {
    int certs;
    int serializedData;
    int encoded;
  }
  int rootCA;
  int rootPrincipal;
  int providerName;
  int provider;
}
class SpiEngUtils {
  class MyProvider {
  }
  int invalidValues;
}
class SignerStub {
}
class SecurityChecker {
  int checkAsserted;
  int checkTarget;
  int enableAccess;
}
class RandomImpl {
  int runEngineSetSeed;
  int runEngineNextBytes;
  int runEngineGenerateSeed;
}
class PublicKeyStub {
  int encoded;
  int format;
  int algorithm;
  int serialVersionUID;
}
class PrivateKeyStub {
  int encoded;
  int format;
  int algorithm;
  int serialVersionUID;
}
class MyTrustManagerFactorySpi {
  class Parameters {
    int keyStore;
  }
}
class MySignature2 {
  int runEngineGetParameter;
  int runEngineSetParameter;
  int runEngineVerify;
  int runEngineSign;
  int runEngineUpdate2;
  int runEngineUpdate1;
  int runEngineInitSign;
  int runEngineInitVerify;
}
class MySignature1 {
  int BUFFER_LENGTH;
  int UNINITIALIZED;
  int VERIFY;
  int SIGN;
  int runEngineGetParameter;
  int runEngineSetParameter;
  int runEngineVerify;
  int runEngineSign;
  int runEngineUpdate2;
  int runEngineUpdate1;
  int runEngineInitSign;
  int runEngineInitVerify;
}
class MySSLContextSpi {
  class tmpSSLEngine {
    int tmpPort;
    int tmpHost;
  }
  int init;
}
class MyProvider {
}
class MyMessageDigest2 {
  int runEngineUpdate2;
  int runEngineUpdate1;
  int runEngineDigest;
  int runEngineReset;
}
class MyMessageDigest1 {
  int runEngineUpdate2;
  int runEngineUpdate1;
  int runEngineDigest;
  int runEngineReset;
}
class MyLoadStoreParams {
  int protPar;
}
class MyKeyStoreSpi {
  class MyCertificate {
  }
}
class MyKeyStore {
  int DatesSL;
  int ChainSL;
  int CertSL;
  int KeysSL;
  int Dates;
  int Chain;
  int Cert;
  int Keys;
}
class MyKeyPairGeneratorSpi {
}
class MyKeyPairGenerator3 {
}
class MyKeyPairGenerator2 {
  int secureRandom;
  int keySize;
}
class MyKeyPairGenerator1 {
  class PrivKey {
    int encoded;
    int format;
    int algorithm;
  }
  class PubKey {
    int encoded;
    int format;
    int algorithm;
  }
  int paramSpec;
  int secureRandom;
  int keySize;
}
class MyGuard {
  int enabled;
  int serialVersionUID;
}
class MyBasicPermission {
}
class MyAlgorithmParameterGeneratorSpi {
}
class MDGoldenData {
  int goldenData;
  int myMessage;
  int MY_MESSAGE_LEN;
}
class KeyStoreTestSupport {
  class AnotherEntry {
  }
  class ProtPar {
  }
  class MCertificate {
    int type;
    int encoding;
  }
  class MyPrivateKey {
    int encoded;
    int format;
    int algorithm;
  }
  class SKey {
    int encoded;
    int type;
  }
  int defaultProvider;
  int defaultProviderName;
  int JKSSupported;
  int defaultType;
  int validValues;
  int srvKeyStore;
}
class IdentityStub {
}
class IdentityScopeStub {
}
class CertificateStub {
  int key;
  int principal;
  int guarantor;
  int format;
}
